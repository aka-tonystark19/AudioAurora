/*
 * This source file contains a Verilog description of an IP core
 * automatically generated by the SPIRAL HDL Generator.
 *
 * This product includes a hardware design developed by Carnegie Mellon University.
 *
 * Copyright (c) 2005-2011 by Peter A. Milder for the SPIRAL Project,
 * Carnegie Mellon University
 *
 * For more information, see the SPIRAL project website at:
 *   http://www.spiral.net
 *
 * This design is provided for internal, non-commercial research use only
 * and is not for redistribution, with or without modifications.
 * 
 * You may not use the name "Carnegie Mellon University" or derivations
 * thereof to endorse or promote products derived from this software.
 *
 * THE SOFTWARE IS PROVIDED "AS-IS" WITHOUT ANY WARRANTY OF ANY KIND, EITHER
 * EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT LIMITED TO ANY WARRANTY
 * THAT THE SOFTWARE WILL CONFORM TO SPECIFICATIONS OR BE ERROR-FREE AND ANY
 * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,
 * TITLE, OR NON-INFRINGEMENT.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * BE LIABLE FOR ANY DAMAGES, INCLUDING BUT NOT LIMITED TO DIRECT, INDIRECT,
 * SPECIAL OR CONSEQUENTIAL DAMAGES, ARISING OUT OF, RESULTING FROM, OR IN
 * ANY WAY CONNECTED WITH THIS SOFTWARE (WHETHER OR NOT BASED UPON WARRANTY,
 * CONTRACT, TORT OR OTHERWISE).
 *
 */

//   Input/output stream: 2 complex words per cycle
//   Throughput: one transform every 512 cycles
//   Latency: 1409 cycles

//   Resources required:
//     36 multipliers (32 x 32 bit)
//     58 adders (32 x 32 bit)
//     2 RAMs (32 words, 64 bits per word)
//     2 RAMs (256 words, 64 bits per word)
//     2 RAMs (512 words, 64 bits per word)
//     2 RAMs (16 words, 64 bits per word)
//     2 RAMs (128 words, 64 bits per word)
//     6 RAMs (1024 words, 64 bits per word)
//     2 RAMs (8 words, 64 bits per word)
//     2 RAMs (64 words, 64 bits per word)
//     2 ROMs (8 words, 32 bits per word)
//     2 ROMs (16 words, 32 bits per word)
//     2 ROMs (128 words, 32 bits per word)
//     2 ROMs (64 words, 32 bits per word)
//     2 ROMs (32 words, 32 bits per word)
//     2 ROMs (512 words, 32 bits per word)
//     2 ROMs (256 words, 32 bits per word)

// Generated on Mon Mar 13 07:42:32 UTC 2023

// Latency: 1409 clock cycles
// Throughput: 1 transform every 512 cycles


// We use an interleaved complex data format.  X0 represents the
// real portion of the first input, and X1 represents the imaginary
// portion.  The X variables are system inputs and the Y variables
// are system outputs.

// The design uses a system of flag signals to indicate the
// beginning of the input and output data streams.  The 'next'
// input (asserted high), is used to instruct the system that the
// input stream will begin on the following cycle.

// This system has a 'gap' of 512 cycles.  This means that
// 512 cycles must elapse between the beginning of the input
// vectors.

// The output signal 'next_out' (also asserted high) indicates
// that the output vector will begin streaming out of the system
 // on the following cycle.

// The system has a latency of 1409 cycles.  This means that
// the 'next_out' will be asserted 1409 cycles after the user
// asserts 'next'.

// The simple testbench below will demonstrate the timing for loading
// and unloading data vectors.
// The system reset signal is asserted high.

// Please note: when simulating floating point code, you must include
// Xilinx's DSP slice simulation module.

// Latency: 1409
// Gap: 512
// module_name_is:dft_top
module dft_top(clk, reset, next, next_out,
   X0, Y0,
   X1, Y1,
   X2, Y2,
   X3, Y3);

   output next_out;
   input clk, reset, next;

   input [31:0] X0,
      X1,
      X2,
      X3;

   output [31:0] Y0,
      Y1,
      Y2,
      Y3;

   wire [31:0] t0_0;
   wire [31:0] t0_1;
   wire [31:0] t0_2;
   wire [31:0] t0_3;
   wire next_0;
   wire [31:0] t1_0;
   wire [31:0] t1_1;
   wire [31:0] t1_2;
   wire [31:0] t1_3;
   wire next_1;
   wire [31:0] t2_0;
   wire [31:0] t2_1;
   wire [31:0] t2_2;
   wire [31:0] t2_3;
   wire next_2;
   wire [31:0] t3_0;
   wire [31:0] t3_1;
   wire [31:0] t3_2;
   wire [31:0] t3_3;
   wire next_3;
   wire [31:0] t4_0;
   wire [31:0] t4_1;
   wire [31:0] t4_2;
   wire [31:0] t4_3;
   wire next_4;
   wire [31:0] t5_0;
   wire [31:0] t5_1;
   wire [31:0] t5_2;
   wire [31:0] t5_3;
   wire next_5;
   wire [31:0] t6_0;
   wire [31:0] t6_1;
   wire [31:0] t6_2;
   wire [31:0] t6_3;
   wire next_6;
   wire [31:0] t7_0;
   wire [31:0] t7_1;
   wire [31:0] t7_2;
   wire [31:0] t7_3;
   wire next_7;
   wire [31:0] t8_0;
   wire [31:0] t8_1;
   wire [31:0] t8_2;
   wire [31:0] t8_3;
   wire next_8;
   wire [31:0] t9_0;
   wire [31:0] t9_1;
   wire [31:0] t9_2;
   wire [31:0] t9_3;
   wire next_9;
   wire [31:0] t10_0;
   wire [31:0] t10_1;
   wire [31:0] t10_2;
   wire [31:0] t10_3;
   wire next_10;
   wire [31:0] t11_0;
   wire [31:0] t11_1;
   wire [31:0] t11_2;
   wire [31:0] t11_3;
   wire next_11;
   wire [31:0] t12_0;
   wire [31:0] t12_1;
   wire [31:0] t12_2;
   wire [31:0] t12_3;
   wire next_12;
   wire [31:0] t13_0;
   wire [31:0] t13_1;
   wire [31:0] t13_2;
   wire [31:0] t13_3;
   wire next_13;
   wire [31:0] t14_0;
   wire [31:0] t14_1;
   wire [31:0] t14_2;
   wire [31:0] t14_3;
   wire next_14;
   wire [31:0] t15_0;
   wire [31:0] t15_1;
   wire [31:0] t15_2;
   wire [31:0] t15_3;
   wire next_15;
   wire [31:0] t16_0;
   wire [31:0] t16_1;
   wire [31:0] t16_2;
   wire [31:0] t16_3;
   wire next_16;
   wire [31:0] t17_0;
   wire [31:0] t17_1;
   wire [31:0] t17_2;
   wire [31:0] t17_3;
   wire next_17;
   wire [31:0] t18_0;
   wire [31:0] t18_1;
   wire [31:0] t18_2;
   wire [31:0] t18_3;
   wire next_18;
   wire [31:0] t19_0;
   wire [31:0] t19_1;
   wire [31:0] t19_2;
   wire [31:0] t19_3;
   wire next_19;
   wire [31:0] t20_0;
   wire [31:0] t20_1;
   wire [31:0] t20_2;
   wire [31:0] t20_3;
   wire next_20;
   wire [31:0] t21_0;
   wire [31:0] t21_1;
   wire [31:0] t21_2;
   wire [31:0] t21_3;
   wire next_21;
   wire [31:0] t22_0;
   wire [31:0] t22_1;
   wire [31:0] t22_2;
   wire [31:0] t22_3;
   wire next_22;
   wire [31:0] t23_0;
   wire [31:0] t23_1;
   wire [31:0] t23_2;
   wire [31:0] t23_3;
   wire next_23;
   wire [31:0] t24_0;
   wire [31:0] t24_1;
   wire [31:0] t24_2;
   wire [31:0] t24_3;
   wire next_24;
   wire [31:0] t25_0;
   wire [31:0] t25_1;
   wire [31:0] t25_2;
   wire [31:0] t25_3;
   wire next_25;
   wire [31:0] t26_0;
   wire [31:0] t26_1;
   wire [31:0] t26_2;
   wire [31:0] t26_3;
   wire next_26;
   wire [31:0] t27_0;
   wire [31:0] t27_1;
   wire [31:0] t27_2;
   wire [31:0] t27_3;
   wire next_27;
   wire [31:0] t28_0;
   wire [31:0] t28_1;
   wire [31:0] t28_2;
   wire [31:0] t28_3;
   wire next_28;
   wire [31:0] t29_0;
   wire [31:0] t29_1;
   wire [31:0] t29_2;
   wire [31:0] t29_3;
   wire next_29;
   wire [31:0] t30_0;
   wire [31:0] t30_1;
   wire [31:0] t30_2;
   wire [31:0] t30_3;
   wire next_30;
   assign t0_0 = X0;
   assign Y0 = t30_0;
   assign t0_1 = X1;
   assign Y1 = t30_1;
   assign t0_2 = X2;
   assign Y2 = t30_2;
   assign t0_3 = X3;
   assign Y3 = t30_3;
   assign next_0 = next;
   assign next_out = next_30;

// latency=484, gap=512
   rc51686 stage0(.clk(clk), .reset(reset), .next(next_0), .next_out(next_1),
    .X0(t0_0), .Y0(t1_0),
    .X1(t0_1), .Y1(t1_1),
    .X2(t0_2), .Y2(t1_2),
    .X3(t0_3), .Y3(t1_3));


// latency=2, gap=512
   codeBlock51688 stage1(.clk(clk), .reset(reset), .next_in(next_1), .next_out(next_2),
       .X0_in(t1_0), .Y0(t2_0),
       .X1_in(t1_1), .Y1(t2_1),
       .X2_in(t1_2), .Y2(t2_2),
       .X3_in(t1_3), .Y3(t2_3));


// latency=4, gap=512
   rc51769 stage2(.clk(clk), .reset(reset), .next(next_2), .next_out(next_3),
    .X0(t2_0), .Y0(t3_0),
    .X1(t2_1), .Y1(t3_1),
    .X2(t2_2), .Y2(t3_2),
    .X3(t2_3), .Y3(t3_3));


// latency=12, gap=512
   DirSum_51950 stage3(.next(next_3), .clk(clk), .reset(reset), .next_out(next_4),
       .X0(t3_0), .Y0(t4_0),
       .X1(t3_1), .Y1(t4_1),
       .X2(t3_2), .Y2(t4_2),
       .X3(t3_3), .Y3(t4_3));


// latency=2, gap=512
   codeBlock51953 stage4(.clk(clk), .reset(reset), .next_in(next_4), .next_out(next_5),
       .X0_in(t4_0), .Y0(t5_0),
       .X1_in(t4_1), .Y1(t5_1),
       .X2_in(t4_2), .Y2(t5_2),
       .X3_in(t4_3), .Y3(t5_3));


// latency=5, gap=512
   rc52034 stage5(.clk(clk), .reset(reset), .next(next_5), .next_out(next_6),
    .X0(t5_0), .Y0(t6_0),
    .X1(t5_1), .Y1(t6_1),
    .X2(t5_2), .Y2(t6_2),
    .X3(t5_3), .Y3(t6_3));


// latency=12, gap=512
   DirSum_52223 stage6(.next(next_6), .clk(clk), .reset(reset), .next_out(next_7),
       .X0(t6_0), .Y0(t7_0),
       .X1(t6_1), .Y1(t7_1),
       .X2(t6_2), .Y2(t7_2),
       .X3(t6_3), .Y3(t7_3));


// latency=2, gap=512
   codeBlock52226 stage7(.clk(clk), .reset(reset), .next_in(next_7), .next_out(next_8),
       .X0_in(t7_0), .Y0(t8_0),
       .X1_in(t7_1), .Y1(t8_1),
       .X2_in(t7_2), .Y2(t8_2),
       .X3_in(t7_3), .Y3(t8_3));


// latency=7, gap=512
   rc52307 stage8(.clk(clk), .reset(reset), .next(next_8), .next_out(next_9),
    .X0(t8_0), .Y0(t9_0),
    .X1(t8_1), .Y1(t9_1),
    .X2(t8_2), .Y2(t9_2),
    .X3(t8_3), .Y3(t9_3));


// latency=12, gap=512
   DirSum_52512 stage9(.next(next_9), .clk(clk), .reset(reset), .next_out(next_10),
       .X0(t9_0), .Y0(t10_0),
       .X1(t9_1), .Y1(t10_1),
       .X2(t9_2), .Y2(t10_2),
       .X3(t9_3), .Y3(t10_3));


// latency=2, gap=512
   codeBlock52515 stage10(.clk(clk), .reset(reset), .next_in(next_10), .next_out(next_11),
       .X0_in(t10_0), .Y0(t11_0),
       .X1_in(t10_1), .Y1(t11_1),
       .X2_in(t10_2), .Y2(t11_2),
       .X3_in(t10_3), .Y3(t11_3));


// latency=11, gap=512
   rc52596 stage11(.clk(clk), .reset(reset), .next(next_11), .next_out(next_12),
    .X0(t11_0), .Y0(t12_0),
    .X1(t11_1), .Y1(t12_1),
    .X2(t11_2), .Y2(t12_2),
    .X3(t11_3), .Y3(t12_3));


// latency=12, gap=512
   DirSum_52833 stage12(.next(next_12), .clk(clk), .reset(reset), .next_out(next_13),
       .X0(t12_0), .Y0(t13_0),
       .X1(t12_1), .Y1(t13_1),
       .X2(t12_2), .Y2(t13_2),
       .X3(t12_3), .Y3(t13_3));


// latency=2, gap=512
   codeBlock52836 stage13(.clk(clk), .reset(reset), .next_in(next_13), .next_out(next_14),
       .X0_in(t13_0), .Y0(t14_0),
       .X1_in(t13_1), .Y1(t14_1),
       .X2_in(t13_2), .Y2(t14_2),
       .X3_in(t13_3), .Y3(t14_3));


// latency=19, gap=512
   rc52917 stage14(.clk(clk), .reset(reset), .next(next_14), .next_out(next_15),
    .X0(t14_0), .Y0(t15_0),
    .X1(t14_1), .Y1(t15_1),
    .X2(t14_2), .Y2(t15_2),
    .X3(t14_3), .Y3(t15_3));


// latency=12, gap=512
   DirSum_53218 stage15(.next(next_15), .clk(clk), .reset(reset), .next_out(next_16),
       .X0(t15_0), .Y0(t16_0),
       .X1(t15_1), .Y1(t16_1),
       .X2(t15_2), .Y2(t16_2),
       .X3(t15_3), .Y3(t16_3));


// latency=2, gap=512
   codeBlock53221 stage16(.clk(clk), .reset(reset), .next_in(next_16), .next_out(next_17),
       .X0_in(t16_0), .Y0(t17_0),
       .X1_in(t16_1), .Y1(t17_1),
       .X2_in(t16_2), .Y2(t17_2),
       .X3_in(t16_3), .Y3(t17_3));


// latency=35, gap=512
   rc53302 stage17(.clk(clk), .reset(reset), .next(next_17), .next_out(next_18),
    .X0(t17_0), .Y0(t18_0),
    .X1(t17_1), .Y1(t18_1),
    .X2(t17_2), .Y2(t18_2),
    .X3(t17_3), .Y3(t18_3));


// latency=12, gap=512
   DirSum_53731 stage18(.next(next_18), .clk(clk), .reset(reset), .next_out(next_19),
       .X0(t18_0), .Y0(t19_0),
       .X1(t18_1), .Y1(t19_1),
       .X2(t18_2), .Y2(t19_2),
       .X3(t18_3), .Y3(t19_3));


// latency=2, gap=512
   codeBlock53734 stage19(.clk(clk), .reset(reset), .next_in(next_19), .next_out(next_20),
       .X0_in(t19_0), .Y0(t20_0),
       .X1_in(t19_1), .Y1(t20_1),
       .X2_in(t19_2), .Y2(t20_2),
       .X3_in(t19_3), .Y3(t20_3));


// latency=67, gap=512
   rc53815 stage20(.clk(clk), .reset(reset), .next(next_20), .next_out(next_21),
    .X0(t20_0), .Y0(t21_0),
    .X1(t20_1), .Y1(t21_1),
    .X2(t20_2), .Y2(t21_2),
    .X3(t20_3), .Y3(t21_3));


// latency=12, gap=512
   DirSum_54500 stage21(.next(next_21), .clk(clk), .reset(reset), .next_out(next_22),
       .X0(t21_0), .Y0(t22_0),
       .X1(t21_1), .Y1(t22_1),
       .X2(t21_2), .Y2(t22_2),
       .X3(t21_3), .Y3(t22_3));


// latency=2, gap=512
   codeBlock54503 stage22(.clk(clk), .reset(reset), .next_in(next_22), .next_out(next_23),
       .X0_in(t22_0), .Y0(t23_0),
       .X1_in(t22_1), .Y1(t23_1),
       .X2_in(t22_2), .Y2(t23_2),
       .X3_in(t22_3), .Y3(t23_3));


// latency=131, gap=512
   rc54584 stage23(.clk(clk), .reset(reset), .next(next_23), .next_out(next_24),
    .X0(t23_0), .Y0(t24_0),
    .X1(t23_1), .Y1(t24_1),
    .X2(t23_2), .Y2(t24_2),
    .X3(t23_3), .Y3(t24_3));


// latency=12, gap=512
   DirSum_55781 stage24(.next(next_24), .clk(clk), .reset(reset), .next_out(next_25),
       .X0(t24_0), .Y0(t25_0),
       .X1(t24_1), .Y1(t25_1),
       .X2(t24_2), .Y2(t25_2),
       .X3(t24_3), .Y3(t25_3));


// latency=2, gap=512
   codeBlock55784 stage25(.clk(clk), .reset(reset), .next_in(next_25), .next_out(next_26),
       .X0_in(t25_0), .Y0(t26_0),
       .X1_in(t25_1), .Y1(t26_1),
       .X2_in(t25_2), .Y2(t26_2),
       .X3_in(t25_3), .Y3(t26_3));


// latency=259, gap=512
   rc55865 stage26(.clk(clk), .reset(reset), .next(next_26), .next_out(next_27),
    .X0(t26_0), .Y0(t27_0),
    .X1(t26_1), .Y1(t27_1),
    .X2(t26_2), .Y2(t27_2),
    .X3(t26_3), .Y3(t27_3));


// latency=12, gap=512
   DirSum_58085 stage27(.next(next_27), .clk(clk), .reset(reset), .next_out(next_28),
       .X0(t27_0), .Y0(t28_0),
       .X1(t27_1), .Y1(t28_1),
       .X2(t27_2), .Y2(t28_2),
       .X3(t27_3), .Y3(t28_3));


// latency=2, gap=512
   codeBlock58088 stage28(.clk(clk), .reset(reset), .next_in(next_28), .next_out(next_29),
       .X0_in(t28_0), .Y0(t29_0),
       .X1_in(t28_1), .Y1(t29_1),
       .X2_in(t28_2), .Y2(t29_2),
       .X3_in(t28_3), .Y3(t29_3));


// latency=259, gap=512
   rc58169 stage29(.clk(clk), .reset(reset), .next(next_29), .next_out(next_30),
    .X0(t29_0), .Y0(t30_0),
    .X1(t29_1), .Y1(t30_1),
    .X2(t29_2), .Y2(t30_2),
    .X3(t29_3), .Y3(t30_3));


endmodule

// Latency: 484
// Gap: 512
module rc51686(clk, reset, next, next_out,
   X0, Y0,
   X1, Y1,
   X2, Y2,
   X3, Y3);

   output next_out;
   input clk, reset, next;

   input [31:0] X0,
      X1,
      X2,
      X3;

   output [31:0] Y0,
      Y1,
      Y2,
      Y3;

   wire [63:0] t0;
   wire [63:0] s0;
   assign t0 = {X0, X1};
   wire [63:0] t1;
   wire [63:0] s1;
   assign t1 = {X2, X3};
   assign Y0 = s0[63:32];
   assign Y1 = s0[31:0];
   assign Y2 = s1[63:32];
   assign Y3 = s1[31:0];

   perm51684 instPerm59954(.x0(t0), .y0(s0),
    .x1(t1), .y1(s1),
   .clk(clk), .next(next), .next_out(next_out), .reset(reset)
);



endmodule

// Latency: 484
// Gap: 512
module perm51684(clk, next, reset, next_out,
   x0, y0,
   x1, y1);
   parameter numBanks = 2;
   parameter logBanks = 1;
   parameter depth = 512;
   parameter logDepth = 9;
   parameter width = 64;

   input [width-1:0]  x0;
   output [width-1:0]  y0;
   wire [width-1:0]  ybuff0;
   input [width-1:0]  x1;
   output [width-1:0]  y1;
   wire [width-1:0]  ybuff1;
   input 	      clk, next, reset;
   output 	     next_out;

   wire    	     next0;

   reg              inFlip0, outFlip0;
   reg              inActive, outActive;

   wire [logBanks-1:0] inBank0, outBank0;
   wire [logDepth-1:0] inAddr0, outAddr0;
   wire [logBanks-1:0] outBank_a0;
   wire [logDepth-1:0] outAddr_a0;
   wire [logDepth+logBanks-1:0] addr0, addr0b, addr0c;
   wire [logBanks-1:0] inBank1, outBank1;
   wire [logDepth-1:0] inAddr1, outAddr1;
   wire [logBanks-1:0] outBank_a1;
   wire [logDepth-1:0] outAddr_a1;
   wire [logDepth+logBanks-1:0] addr1, addr1b, addr1c;


   reg [logDepth-1:0]  inCount, outCount, outCount_d, outCount_dd, outCount_for_rd_addr, outCount_for_rd_data;  

   assign    addr0 = {inCount, 1'd0};
   assign    addr0b = {outCount, 1'd0};
   assign    addr0c = {outCount_for_rd_addr, 1'd0};
   assign    addr1 = {inCount, 1'd1};
   assign    addr1b = {outCount, 1'd1};
   assign    addr1c = {outCount_for_rd_addr, 1'd1};
    wire [width+logDepth-1:0] w_0_0, w_0_1, w_1_0, w_1_1;

    reg [width-1:0] z_0_0;
    reg [width-1:0] z_0_1;
    wire [width-1:0] z_1_0, z_1_1;

    wire [logDepth-1:0] u_0_0, u_0_1, u_1_0, u_1_1;

    always @(posedge clk) begin
    end

   assign inBank0[0] = addr0[9] ^ addr0[0];
   assign inAddr0[0] = addr0[8];
   assign inAddr0[1] = addr0[7];
   assign inAddr0[2] = addr0[6];
   assign inAddr0[3] = addr0[5];
   assign inAddr0[4] = addr0[4];
   assign inAddr0[5] = addr0[3];
   assign inAddr0[6] = addr0[2];
   assign inAddr0[7] = addr0[1];
   assign inAddr0[8] = addr0[0];
   assign outBank0[0] = addr0b[9] ^ addr0b[0];
   assign outAddr0[0] = addr0b[1];
   assign outAddr0[1] = addr0b[2];
   assign outAddr0[2] = addr0b[3];
   assign outAddr0[3] = addr0b[4];
   assign outAddr0[4] = addr0b[5];
   assign outAddr0[5] = addr0b[6];
   assign outAddr0[6] = addr0b[7];
   assign outAddr0[7] = addr0b[8];
   assign outAddr0[8] = addr0b[9];
   assign outBank_a0[0] = addr0c[9] ^ addr0c[0];
   assign outAddr_a0[0] = addr0c[1];
   assign outAddr_a0[1] = addr0c[2];
   assign outAddr_a0[2] = addr0c[3];
   assign outAddr_a0[3] = addr0c[4];
   assign outAddr_a0[4] = addr0c[5];
   assign outAddr_a0[5] = addr0c[6];
   assign outAddr_a0[6] = addr0c[7];
   assign outAddr_a0[7] = addr0c[8];
   assign outAddr_a0[8] = addr0c[9];

   assign inBank1[0] = addr1[9] ^ addr1[0];
   assign inAddr1[0] = addr1[8];
   assign inAddr1[1] = addr1[7];
   assign inAddr1[2] = addr1[6];
   assign inAddr1[3] = addr1[5];
   assign inAddr1[4] = addr1[4];
   assign inAddr1[5] = addr1[3];
   assign inAddr1[6] = addr1[2];
   assign inAddr1[7] = addr1[1];
   assign inAddr1[8] = addr1[0];
   assign outBank1[0] = addr1b[9] ^ addr1b[0];
   assign outAddr1[0] = addr1b[1];
   assign outAddr1[1] = addr1b[2];
   assign outAddr1[2] = addr1b[3];
   assign outAddr1[3] = addr1b[4];
   assign outAddr1[4] = addr1b[5];
   assign outAddr1[5] = addr1b[6];
   assign outAddr1[6] = addr1b[7];
   assign outAddr1[7] = addr1b[8];
   assign outAddr1[8] = addr1b[9];
   assign outBank_a1[0] = addr1c[9] ^ addr1c[0];
   assign outAddr_a1[0] = addr1c[1];
   assign outAddr_a1[1] = addr1c[2];
   assign outAddr_a1[2] = addr1c[3];
   assign outAddr_a1[3] = addr1c[4];
   assign outAddr_a1[4] = addr1c[5];
   assign outAddr_a1[5] = addr1c[6];
   assign outAddr_a1[6] = addr1c[7];
   assign outAddr_a1[7] = addr1c[8];
   assign outAddr_a1[8] = addr1c[9];

   nextReg #(482, 9) nextReg_59959(.X(next), .Y(next0), .reset(reset), .clk(clk));


   shiftRegFIFO #(2, 1) shiftFIFO_59962(.X(next0), .Y(next_out), .clk(clk));


   memArray1024_51684 #(numBanks, logBanks, depth, logDepth, width)
     memSys(.inFlip(inFlip0), .outFlip(outFlip0), .next(next), .reset(reset),
        .x0(w_1_0[width+logDepth-1:logDepth]), .y0(ybuff0),
        .inAddr0(w_1_0[logDepth-1:0]),
        .outAddr0(u_1_0), 
        .x1(w_1_1[width+logDepth-1:logDepth]), .y1(ybuff1),
        .inAddr1(w_1_1[logDepth-1:0]),
        .outAddr1(u_1_1), 
        .clk(clk));

   always @(posedge clk) begin
      if (reset == 1) begin
      z_0_0 <= 0;
      z_0_1 <= 0;
         inFlip0 <= 0; outFlip0 <= 1; outCount <= 0; inCount <= 0;
        outCount_for_rd_addr <= 0;
        outCount_for_rd_data <= 0;
      end
      else begin
          outCount_d <= outCount;
          outCount_dd <= outCount_d;
         if (inCount == 481)
            outCount_for_rd_addr <= 0;
         else
            outCount_for_rd_addr <= outCount_for_rd_addr+1;
         if (inCount == 483)
            outCount_for_rd_data <= 0;
         else
            outCount_for_rd_data <= outCount_for_rd_data+1;
      z_0_0 <= ybuff0;
      z_0_1 <= ybuff1;
         if (inCount == 481) begin
            outFlip0 <= ~outFlip0;
            outCount <= 0;
         end
         else
            outCount <= outCount+1;
         if (inCount == 511) begin
            inFlip0 <= ~inFlip0;
         end
         if (next == 1) begin
            if (inCount >= 481)
               inFlip0 <= ~inFlip0;
            inCount <= 0;
         end
         else
            inCount <= inCount + 1;
      end
   end
    assign w_0_0 = {x0, inAddr0};
    assign w_0_1 = {x1, inAddr1};
    assign y0 = z_1_0;
    assign y1 = z_1_1;
    assign u_0_0 = outAddr_a0;
    assign u_0_1 = outAddr_a1;
    wire wr_ctrl_st_0;
    assign wr_ctrl_st_0 = inCount[8];

    switch #(logDepth+width) in_sw_0_0(.x0(w_0_0), .x1(w_0_1), .y0(w_1_0), .y1(w_1_1), .ctrl(wr_ctrl_st_0));
    wire rdd_ctrl_st_0;
    assign rdd_ctrl_st_0 = outCount_for_rd_data[8];

    switch #(width) out_sw_0_0(.x0(z_0_0), .x1(z_0_1), .y0(z_1_0), .y1(z_1_1), .ctrl(rdd_ctrl_st_0));
    wire rda_ctrl_st_0;
    assign rda_ctrl_st_0 = outCount_for_rd_addr[8];

    switch #(logDepth) rdaddr_sw_0_0(.x0(u_0_0), .x1(u_0_1), .y0(u_1_0), .y1(u_1_1), .ctrl(rda_ctrl_st_0));
endmodule

module memArray1024_51684(next, reset,
                x0, y0,
                inAddr0,
                outAddr0,
                x1, y1,
                inAddr1,
                outAddr1,
                clk, inFlip, outFlip);

   parameter numBanks = 2;
   parameter logBanks = 1;
   parameter depth = 512;
   parameter logDepth = 9;
   parameter width = 64;
         
   input     clk, next, reset;
   input    inFlip, outFlip;
   wire    next0;
   
   input [width-1:0]   x0;
   output [width-1:0]  y0;
   input [logDepth-1:0] inAddr0, outAddr0;
   input [width-1:0]   x1;
   output [width-1:0]  y1;
   input [logDepth-1:0] inAddr1, outAddr1;
   nextReg #(512, 9) nextReg_59967(.X(next), .Y(next0), .reset(reset), .clk(clk));


   memMod #(depth*2, width, logDepth+1) 
     memMod0(.in(x0), .out(y0), .inAddr({inFlip, inAddr0}),
	   .outAddr({outFlip, outAddr0}), .writeSel(1'b1), .clk(clk));   
   memMod #(depth*2, width, logDepth+1) 
     memMod1(.in(x1), .out(y1), .inAddr({inFlip, inAddr1}),
	   .outAddr({outFlip, outAddr1}), .writeSel(1'b1), .clk(clk));   
endmodule

module nextReg(X, Y, reset, clk);
   parameter depth=2, logDepth=1;

   output Y;
   input X;
   input              clk, reset;
   reg [logDepth:0] count;
   reg                active;

   assign Y = (count == depth) ? 1 : 0;

   always @ (posedge clk) begin
      if (reset == 1) begin
         count <= 0;
         active <= 0;
      end
      else if (X == 1) begin
         active <= 1;
         count <= 1;
      end
      else if (count == depth) begin
         count <= 0;
         active <= 0;
      end
      else if (active)
         count <= count+1;
   end
endmodule


module memMod(in, out, inAddr, outAddr, writeSel, clk);
   
   parameter depth=1024, width=16, logDepth=10;
   
   input [width-1:0]    in;
   input [logDepth-1:0] inAddr, outAddr;
   input 	        writeSel, clk;
   output [width-1:0] 	out;
   reg [width-1:0] 	out;
   
   // synthesis attribute ram_style of mem is block

   reg [width-1:0] 	mem[depth-1:0]; 
   
   always @(posedge clk) begin
      out <= mem[outAddr];
      
      if (writeSel)
        mem[inAddr] <= in;
   end
endmodule 



module memMod_dist(in, out, inAddr, outAddr, writeSel, clk);
   
   parameter depth=1024, width=16, logDepth=10;
   
   input [width-1:0]    in;
   input [logDepth-1:0] inAddr, outAddr;
   input 	        writeSel, clk;
   output [width-1:0] 	out;
   reg [width-1:0] 	out;
   
   // synthesis attribute ram_style of mem is distributed

   reg [width-1:0] 	mem[depth-1:0]; 
   
   always @(posedge clk) begin
      out <= mem[outAddr];
      
      if (writeSel)
        mem[inAddr] <= in;
   end
endmodule 

module switch(ctrl, x0, x1, y0, y1);
    parameter width = 16;
    input [width-1:0] x0, x1;
    output [width-1:0] y0, y1;
    input ctrl;
    assign y0 = (ctrl == 0) ? x0 : x1;
    assign y1 = (ctrl == 0) ? x1 : x0;
endmodule

module shiftRegFIFO(X, Y, clk);
   parameter depth=1, width=1;

   output [width-1:0] Y;
   input  [width-1:0] X;
   input              clk;

   reg [width-1:0]    mem [depth-1:0];
   integer            index;

   assign Y = mem[depth-1];

   always @ (posedge clk) begin
      for(index=1;index<depth;index=index+1) begin
         mem[index] <= mem[index-1];
      end
      mem[0]<=X;
   end
endmodule

// Latency: 2
// Gap: 1
module codeBlock51688(clk, reset, next_in, next_out,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3);

   output next_out;
   input clk, reset, next_in;

   reg next;

   input [31:0] X0_in,
      X1_in,
      X2_in,
      X3_in;

   reg   [31:0] X0,
      X1,
      X2,
      X3;

   output [31:0] Y0,
      Y1,
      Y2,
      Y3;

   shiftRegFIFO #(1, 1) shiftFIFO_59974(.X(next), .Y(next_out), .clk(clk));


   wire signed [31:0] a550;
   wire signed [31:0] a551;
   wire signed [31:0] a552;
   wire signed [31:0] a553;
   wire signed [31:0] t237;
   wire signed [31:0] t238;
   wire signed [31:0] t239;
   wire signed [31:0] t240;
   wire signed [31:0] Y0;
   wire signed [31:0] Y1;
   wire signed [31:0] Y2;
   wire signed [31:0] Y3;


   assign a550 = X0;
   assign a551 = X2;
   assign a552 = X1;
   assign a553 = X3;
   assign Y0 = t237;
   assign Y1 = t238;
   assign Y2 = t239;
   assign Y3 = t240;

    addfxp #(32, 1) add51700(.a(a550), .b(a551), .clk(clk), .q(t237));    // 0
    addfxp #(32, 1) add51715(.a(a552), .b(a553), .clk(clk), .q(t238));    // 0
    subfxp #(32, 1) sub51730(.a(a550), .b(a551), .clk(clk), .q(t239));    // 0
    subfxp #(32, 1) sub51745(.a(a552), .b(a553), .clk(clk), .q(t240));    // 0


   always @(posedge clk) begin
      if (reset == 1) begin
      end
      else begin
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         next <= next_in;
      end
   end
endmodule

// Latency: 4
// Gap: 2
module rc51769(clk, reset, next, next_out,
   X0, Y0,
   X1, Y1,
   X2, Y2,
   X3, Y3);

   output next_out;
   input clk, reset, next;

   input [31:0] X0,
      X1,
      X2,
      X3;

   output [31:0] Y0,
      Y1,
      Y2,
      Y3;

   wire [63:0] t0;
   wire [63:0] s0;
   assign t0 = {X0, X1};
   wire [63:0] t1;
   wire [63:0] s1;
   assign t1 = {X2, X3};
   assign Y0 = s0[63:32];
   assign Y1 = s0[31:0];
   assign Y2 = s1[63:32];
   assign Y3 = s1[31:0];

   perm51767 instPerm59975(.x0(t0), .y0(s0),
    .x1(t1), .y1(s1),
   .clk(clk), .next(next), .next_out(next_out), .reset(reset)
);



endmodule

// Latency: 4
// Gap: 2
module perm51767(clk, next, reset, next_out,
   x0, y0,
   x1, y1);
   parameter numBanks = 2;
   parameter logBanks = 1;
   parameter depth = 2;
   parameter logDepth = 1;
   parameter width = 64;

   input [width-1:0]  x0;
   output [width-1:0]  y0;
   wire [width-1:0]  ybuff0;
   input [width-1:0]  x1;
   output [width-1:0]  y1;
   wire [width-1:0]  ybuff1;
   input 	      clk, next, reset;
   output 	     next_out;

   wire    	     next0;

   reg              inFlip0, outFlip0;
   reg              inActive, outActive;

   wire [logBanks-1:0] inBank0, outBank0;
   wire [logDepth-1:0] inAddr0, outAddr0;
   wire [logBanks-1:0] outBank_a0;
   wire [logDepth-1:0] outAddr_a0;
   wire [logDepth+logBanks-1:0] addr0, addr0b, addr0c;
   wire [logBanks-1:0] inBank1, outBank1;
   wire [logDepth-1:0] inAddr1, outAddr1;
   wire [logBanks-1:0] outBank_a1;
   wire [logDepth-1:0] outAddr_a1;
   wire [logDepth+logBanks-1:0] addr1, addr1b, addr1c;


   reg [logDepth-1:0]  inCount, outCount, outCount_d, outCount_dd, outCount_for_rd_addr, outCount_for_rd_data;  

   assign    addr0 = {inCount, 1'd0};
   assign    addr0b = {outCount, 1'd0};
   assign    addr0c = {outCount_for_rd_addr, 1'd0};
   assign    addr1 = {inCount, 1'd1};
   assign    addr1b = {outCount, 1'd1};
   assign    addr1c = {outCount_for_rd_addr, 1'd1};
    wire [width+logDepth-1:0] w_0_0, w_0_1, w_1_0, w_1_1;

    reg [width-1:0] z_0_0;
    reg [width-1:0] z_0_1;
    wire [width-1:0] z_1_0, z_1_1;

    wire [logDepth-1:0] u_0_0, u_0_1, u_1_0, u_1_1;

    always @(posedge clk) begin
    end

   assign inBank0[0] = addr0[1] ^ addr0[0];
   assign inAddr0[0] = addr0[0];
   assign outBank0[0] = addr0b[1] ^ addr0b[0];
   assign outAddr0[0] = addr0b[1];
   assign outBank_a0[0] = addr0c[1] ^ addr0c[0];
   assign outAddr_a0[0] = addr0c[1];

   assign inBank1[0] = addr1[1] ^ addr1[0];
   assign inAddr1[0] = addr1[0];
   assign outBank1[0] = addr1b[1] ^ addr1b[0];
   assign outAddr1[0] = addr1b[1];
   assign outBank_a1[0] = addr1c[1] ^ addr1c[0];
   assign outAddr_a1[0] = addr1c[1];

   shiftRegFIFO #(2, 1) shiftFIFO_59978(.X(next), .Y(next0), .clk(clk));


   shiftRegFIFO #(2, 1) shiftFIFO_59981(.X(next0), .Y(next_out), .clk(clk));


   memArray4_51767 #(numBanks, logBanks, depth, logDepth, width)
     memSys(.inFlip(inFlip0), .outFlip(outFlip0), .next(next), .reset(reset),
        .x0(w_1_0[width+logDepth-1:logDepth]), .y0(ybuff0),
        .inAddr0(w_1_0[logDepth-1:0]),
        .outAddr0(u_1_0), 
        .x1(w_1_1[width+logDepth-1:logDepth]), .y1(ybuff1),
        .inAddr1(w_1_1[logDepth-1:0]),
        .outAddr1(u_1_1), 
        .clk(clk));

    reg resetOutCountRd2_2;
    reg resetOutCountRd2_3;

    always @(posedge clk) begin
        if (reset == 1) begin
            resetOutCountRd2_2 <= 0;
            resetOutCountRd2_3 <= 0;
        end
        else begin
            resetOutCountRd2_2 <= (inCount == 1) ? 1'b1 : 1'b0;
            resetOutCountRd2_3 <= resetOutCountRd2_2;
            if (resetOutCountRd2_3 == 1'b1)
                outCount_for_rd_data <= 0;
            else
                outCount_for_rd_data <= outCount_for_rd_data+1;
        end
    end
   always @(posedge clk) begin
      if (reset == 1) begin
      z_0_0 <= 0;
      z_0_1 <= 0;
         inFlip0 <= 0; outFlip0 <= 1; outCount <= 0; inCount <= 0;
        outCount_for_rd_addr <= 0;
      end
      else begin
          outCount_d <= outCount;
          outCount_dd <= outCount_d;
         if (inCount == 1)
            outCount_for_rd_addr <= 0;
         else
            outCount_for_rd_addr <= outCount_for_rd_addr+1;
      z_0_0 <= ybuff0;
      z_0_1 <= ybuff1;
         if (inCount == 1) begin
            outFlip0 <= ~outFlip0;
            outCount <= 0;
         end
         else
            outCount <= outCount+1;
         if (inCount == 1) begin
            inFlip0 <= ~inFlip0;
         end
         if (next == 1) begin
            if (inCount >= 1)
               inFlip0 <= ~inFlip0;
            inCount <= 0;
         end
         else
            inCount <= inCount + 1;
      end
   end
    assign w_0_0 = {x0, inAddr0};
    assign w_0_1 = {x1, inAddr1};
    assign y0 = z_1_0;
    assign y1 = z_1_1;
    assign u_0_0 = outAddr_a0;
    assign u_0_1 = outAddr_a1;
    wire wr_ctrl_st_0;
    assign wr_ctrl_st_0 = inCount[0];

    switch #(logDepth+width) in_sw_0_0(.x0(w_0_0), .x1(w_0_1), .y0(w_1_0), .y1(w_1_1), .ctrl(wr_ctrl_st_0));
    wire rdd_ctrl_st_0;
    assign rdd_ctrl_st_0 = outCount_for_rd_data[0];

    switch #(width) out_sw_0_0(.x0(z_0_0), .x1(z_0_1), .y0(z_1_0), .y1(z_1_1), .ctrl(rdd_ctrl_st_0));
    wire rda_ctrl_st_0;
    assign rda_ctrl_st_0 = outCount_for_rd_addr[0];

    switch #(logDepth) rdaddr_sw_0_0(.x0(u_0_0), .x1(u_0_1), .y0(u_1_0), .y1(u_1_1), .ctrl(rda_ctrl_st_0));
endmodule

module memArray4_51767(next, reset,
                x0, y0,
                inAddr0,
                outAddr0,
                x1, y1,
                inAddr1,
                outAddr1,
                clk, inFlip, outFlip);

   parameter numBanks = 2;
   parameter logBanks = 1;
   parameter depth = 2;
   parameter logDepth = 1;
   parameter width = 64;
         
   input     clk, next, reset;
   input    inFlip, outFlip;
   wire    next0;
   
   input [width-1:0]   x0;
   output [width-1:0]  y0;
   input [logDepth-1:0] inAddr0, outAddr0;
   input [width-1:0]   x1;
   output [width-1:0]  y1;
   input [logDepth-1:0] inAddr1, outAddr1;
   shiftRegFIFO #(2, 1) shiftFIFO_59984(.X(next), .Y(next0), .clk(clk));


   memMod #(depth*2, width, logDepth+1) 
     memMod0(.in(x0), .out(y0), .inAddr({inFlip, inAddr0}),
	   .outAddr({outFlip, outAddr0}), .writeSel(1'b1), .clk(clk));   
   memMod #(depth*2, width, logDepth+1) 
     memMod1(.in(x1), .out(y1), .inAddr({inFlip, inAddr1}),
	   .outAddr({outFlip, outAddr1}), .writeSel(1'b1), .clk(clk));   
endmodule

// Latency: 12
// Gap: 2
module DirSum_51950(clk, reset, next, next_out,
      X0, Y0,
      X1, Y1,
      X2, Y2,
      X3, Y3);

   output next_out;
   input clk, reset, next;

   reg [0:0] i9;

   input [31:0] X0,
      X1,
      X2,
      X3;

   output [31:0] Y0,
      Y1,
      Y2,
      Y3;

   always @(posedge clk) begin
      if (reset == 1) begin
         i9 <= 0;
      end
      else begin
         if (next == 1)
            i9 <= 0;
         else if (i9 == 1)
            i9 <= 0;
         else
            i9 <= i9 + 1;
      end
   end

   codeBlock51772 codeBlockIsnt59985(.clk(clk), .reset(reset), .next_in(next), .next_out(next_out),
.i9_in(i9),
       .X0_in(X0), .Y0(Y0),
       .X1_in(X1), .Y1(Y1),
       .X2_in(X2), .Y2(Y2),
       .X3_in(X3), .Y3(Y3));

endmodule

module D36_51936(addr, out, clk);
   input clk;
   output [31:0] out;
   reg [31:0] out, out2, out3;
   input [0:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 32'h0;
      1: out3 <= 32'hc0000000;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "block"
endmodule



module D34_51944(addr, out, clk);
   input clk;
   output [31:0] out;
   reg [31:0] out, out2, out3;
   input [0:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 32'h40000000;
      1: out3 <= 32'h0;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "block"
endmodule



// Latency: 12
// Gap: 1
module codeBlock51772(clk, reset, next_in, next_out,
   i9_in,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3);

   output next_out;
   input clk, reset, next_in;

   reg next;
   input [0:0] i9_in;
   reg [0:0] i9;

   input [31:0] X0_in,
      X1_in,
      X2_in,
      X3_in;

   reg   [31:0] X0,
      X1,
      X2,
      X3;

   output [31:0] Y0,
      Y1,
      Y2,
      Y3;

   shiftRegFIFO #(11, 1) shiftFIFO_59988(.X(next), .Y(next_out), .clk(clk));


   wire signed [31:0] a534;
   wire signed [31:0] a523;
   wire signed [31:0] a537;
   wire signed [31:0] a527;
   wire signed [31:0] a538;
   wire signed [31:0] a539;
   reg signed [31:0] tm234;
   reg signed [31:0] tm238;
   reg signed [31:0] tm250;
   reg signed [31:0] tm261;
   reg signed [31:0] tm235;
   reg signed [31:0] tm239;
   reg signed [31:0] tm251;
   reg signed [31:0] tm262;
   wire signed [31:0] tm2;
   wire signed [31:0] a528;
   wire signed [31:0] tm3;
   wire signed [31:0] a530;
   reg signed [31:0] tm236;
   reg signed [31:0] tm240;
   reg signed [31:0] tm252;
   reg signed [31:0] tm263;
   reg signed [31:0] tm40;
   reg signed [31:0] tm41;
   reg signed [31:0] tm237;
   reg signed [31:0] tm241;
   reg signed [31:0] tm253;
   reg signed [31:0] tm264;
   reg signed [31:0] tm254;
   reg signed [31:0] tm265;
   reg signed [31:0] tm255;
   reg signed [31:0] tm266;
   reg signed [31:0] tm256;
   reg signed [31:0] tm267;
   reg signed [31:0] tm257;
   reg signed [31:0] tm268;
   reg signed [31:0] tm258;
   reg signed [31:0] tm269;
   wire signed [31:0] a529;
   wire signed [31:0] a531;
   wire signed [31:0] a532;
   wire signed [31:0] a533;
   reg signed [31:0] tm259;
   reg signed [31:0] tm270;
   wire signed [31:0] Y0;
   wire signed [31:0] Y1;
   wire signed [31:0] Y2;
   wire signed [31:0] Y3;
   reg signed [31:0] tm260;
   reg signed [31:0] tm271;


   assign a534 = X0;
   assign a523 = a534;
   assign a537 = X1;
   assign a527 = a537;
   assign a538 = X2;
   assign a539 = X3;
   assign a528 = tm2;
   assign a530 = tm3;
   assign Y0 = tm260;
   assign Y1 = tm271;

   D36_51936 instD36inst0_51936(.addr(i9[0:0]), .out(tm3), .clk(clk));

   D34_51944 instD34inst0_51944(.addr(i9[0:0]), .out(tm2), .clk(clk));

    multfix #(32, 6) m51871(.a(tm40), .b(tm237), .clk(clk), .q_sc(a529), .q_unsc(), .rst(reset));
    multfix #(32, 6) m51893(.a(tm41), .b(tm241), .clk(clk), .q_sc(a531), .q_unsc(), .rst(reset));
    multfix #(32, 6) m51911(.a(tm41), .b(tm237), .clk(clk), .q_sc(a532), .q_unsc(), .rst(reset));
    multfix #(32, 6) m51922(.a(tm40), .b(tm241), .clk(clk), .q_sc(a533), .q_unsc(), .rst(reset));
    subfxp #(32, 1) sub51900(.a(a529), .b(a531), .clk(clk), .q(Y2));    // 10
    addfxp #(32, 1) add51929(.a(a532), .b(a533), .clk(clk), .q(Y3));    // 10


   always @(posedge clk) begin
      if (reset == 1) begin
         tm40 <= 0;
         tm237 <= 0;
         tm41 <= 0;
         tm241 <= 0;
         tm41 <= 0;
         tm237 <= 0;
         tm40 <= 0;
         tm241 <= 0;
      end
      else begin
         i9 <= i9_in;
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         next <= next_in;
         tm234 <= a538;
         tm238 <= a539;
         tm250 <= a523;
         tm261 <= a527;
         tm235 <= tm234;
         tm239 <= tm238;
         tm251 <= tm250;
         tm262 <= tm261;
         tm236 <= tm235;
         tm240 <= tm239;
         tm252 <= tm251;
         tm263 <= tm262;
         tm40 <= a528;
         tm41 <= a530;
         tm237 <= tm236;
         tm241 <= tm240;
         tm253 <= tm252;
         tm264 <= tm263;
         tm254 <= tm253;
         tm265 <= tm264;
         tm255 <= tm254;
         tm266 <= tm265;
         tm256 <= tm255;
         tm267 <= tm266;
         tm257 <= tm256;
         tm268 <= tm267;
         tm258 <= tm257;
         tm269 <= tm268;
         tm259 <= tm258;
         tm270 <= tm269;
         tm260 <= tm259;
         tm271 <= tm270;
      end
   end
endmodule

// Latency: 2
// Gap: 1
module codeBlock51953(clk, reset, next_in, next_out,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3);

   output next_out;
   input clk, reset, next_in;

   reg next;

   input [31:0] X0_in,
      X1_in,
      X2_in,
      X3_in;

   reg   [31:0] X0,
      X1,
      X2,
      X3;

   output [31:0] Y0,
      Y1,
      Y2,
      Y3;

   shiftRegFIFO #(1, 1) shiftFIFO_59991(.X(next), .Y(next_out), .clk(clk));


   wire signed [31:0] a490;
   wire signed [31:0] a491;
   wire signed [31:0] a492;
   wire signed [31:0] a493;
   wire signed [31:0] t213;
   wire signed [31:0] t214;
   wire signed [31:0] t215;
   wire signed [31:0] t216;
   wire signed [31:0] Y0;
   wire signed [31:0] Y1;
   wire signed [31:0] Y2;
   wire signed [31:0] Y3;


   assign a490 = X0;
   assign a491 = X2;
   assign a492 = X1;
   assign a493 = X3;
   assign Y0 = t213;
   assign Y1 = t214;
   assign Y2 = t215;
   assign Y3 = t216;

    addfxp #(32, 1) add51965(.a(a490), .b(a491), .clk(clk), .q(t213));    // 0
    addfxp #(32, 1) add51980(.a(a492), .b(a493), .clk(clk), .q(t214));    // 0
    subfxp #(32, 1) sub51995(.a(a490), .b(a491), .clk(clk), .q(t215));    // 0
    subfxp #(32, 1) sub52010(.a(a492), .b(a493), .clk(clk), .q(t216));    // 0


   always @(posedge clk) begin
      if (reset == 1) begin
      end
      else begin
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         next <= next_in;
      end
   end
endmodule

// Latency: 5
// Gap: 4
module rc52034(clk, reset, next, next_out,
   X0, Y0,
   X1, Y1,
   X2, Y2,
   X3, Y3);

   output next_out;
   input clk, reset, next;

   input [31:0] X0,
      X1,
      X2,
      X3;

   output [31:0] Y0,
      Y1,
      Y2,
      Y3;

   wire [63:0] t0;
   wire [63:0] s0;
   assign t0 = {X0, X1};
   wire [63:0] t1;
   wire [63:0] s1;
   assign t1 = {X2, X3};
   assign Y0 = s0[63:32];
   assign Y1 = s0[31:0];
   assign Y2 = s1[63:32];
   assign Y3 = s1[31:0];

   perm52032 instPerm59992(.x0(t0), .y0(s0),
    .x1(t1), .y1(s1),
   .clk(clk), .next(next), .next_out(next_out), .reset(reset)
);



endmodule

// Latency: 5
// Gap: 4
module perm52032(clk, next, reset, next_out,
   x0, y0,
   x1, y1);
   parameter numBanks = 2;
   parameter logBanks = 1;
   parameter depth = 4;
   parameter logDepth = 2;
   parameter width = 64;

   input [width-1:0]  x0;
   output [width-1:0]  y0;
   wire [width-1:0]  ybuff0;
   input [width-1:0]  x1;
   output [width-1:0]  y1;
   wire [width-1:0]  ybuff1;
   input 	      clk, next, reset;
   output 	     next_out;

   wire    	     next0;

   reg              inFlip0, outFlip0;
   reg              inActive, outActive;

   wire [logBanks-1:0] inBank0, outBank0;
   wire [logDepth-1:0] inAddr0, outAddr0;
   wire [logBanks-1:0] outBank_a0;
   wire [logDepth-1:0] outAddr_a0;
   wire [logDepth+logBanks-1:0] addr0, addr0b, addr0c;
   wire [logBanks-1:0] inBank1, outBank1;
   wire [logDepth-1:0] inAddr1, outAddr1;
   wire [logBanks-1:0] outBank_a1;
   wire [logDepth-1:0] outAddr_a1;
   wire [logDepth+logBanks-1:0] addr1, addr1b, addr1c;


   reg [logDepth-1:0]  inCount, outCount, outCount_d, outCount_dd, outCount_for_rd_addr, outCount_for_rd_data;  

   assign    addr0 = {inCount, 1'd0};
   assign    addr0b = {outCount, 1'd0};
   assign    addr0c = {outCount_for_rd_addr, 1'd0};
   assign    addr1 = {inCount, 1'd1};
   assign    addr1b = {outCount, 1'd1};
   assign    addr1c = {outCount_for_rd_addr, 1'd1};
    wire [width+logDepth-1:0] w_0_0, w_0_1, w_1_0, w_1_1;

    reg [width-1:0] z_0_0;
    reg [width-1:0] z_0_1;
    wire [width-1:0] z_1_0, z_1_1;

    wire [logDepth-1:0] u_0_0, u_0_1, u_1_0, u_1_1;

    always @(posedge clk) begin
    end

   assign inBank0[0] = addr0[2] ^ addr0[0];
   assign inAddr0[0] = addr0[1];
   assign inAddr0[1] = addr0[0];
   assign outBank0[0] = addr0b[2] ^ addr0b[0];
   assign outAddr0[0] = addr0b[1];
   assign outAddr0[1] = addr0b[2];
   assign outBank_a0[0] = addr0c[2] ^ addr0c[0];
   assign outAddr_a0[0] = addr0c[1];
   assign outAddr_a0[1] = addr0c[2];

   assign inBank1[0] = addr1[2] ^ addr1[0];
   assign inAddr1[0] = addr1[1];
   assign inAddr1[1] = addr1[0];
   assign outBank1[0] = addr1b[2] ^ addr1b[0];
   assign outAddr1[0] = addr1b[1];
   assign outAddr1[1] = addr1b[2];
   assign outBank_a1[0] = addr1c[2] ^ addr1c[0];
   assign outAddr_a1[0] = addr1c[1];
   assign outAddr_a1[1] = addr1c[2];

   shiftRegFIFO #(3, 1) shiftFIFO_59995(.X(next), .Y(next0), .clk(clk));


   shiftRegFIFO #(2, 1) shiftFIFO_59998(.X(next0), .Y(next_out), .clk(clk));


   memArray8_52032 #(numBanks, logBanks, depth, logDepth, width)
     memSys(.inFlip(inFlip0), .outFlip(outFlip0), .next(next), .reset(reset),
        .x0(w_1_0[width+logDepth-1:logDepth]), .y0(ybuff0),
        .inAddr0(w_1_0[logDepth-1:0]),
        .outAddr0(u_1_0), 
        .x1(w_1_1[width+logDepth-1:logDepth]), .y1(ybuff1),
        .inAddr1(w_1_1[logDepth-1:0]),
        .outAddr1(u_1_1), 
        .clk(clk));

    reg resetOutCountRd2_4;

    always @(posedge clk) begin
        if (reset == 1) begin
            resetOutCountRd2_4 <= 0;
        end
        else begin
            resetOutCountRd2_4 <= (inCount == 3) ? 1'b1 : 1'b0;
            if (resetOutCountRd2_4 == 1'b1)
                outCount_for_rd_data <= 0;
            else
                outCount_for_rd_data <= outCount_for_rd_data+1;
        end
    end
   always @(posedge clk) begin
      if (reset == 1) begin
      z_0_0 <= 0;
      z_0_1 <= 0;
         inFlip0 <= 0; outFlip0 <= 1; outCount <= 0; inCount <= 0;
        outCount_for_rd_addr <= 0;
      end
      else begin
          outCount_d <= outCount;
          outCount_dd <= outCount_d;
         if (inCount == 2)
            outCount_for_rd_addr <= 0;
         else
            outCount_for_rd_addr <= outCount_for_rd_addr+1;
      z_0_0 <= ybuff0;
      z_0_1 <= ybuff1;
         if (inCount == 2) begin
            outFlip0 <= ~outFlip0;
            outCount <= 0;
         end
         else
            outCount <= outCount+1;
         if (inCount == 3) begin
            inFlip0 <= ~inFlip0;
         end
         if (next == 1) begin
            if (inCount >= 2)
               inFlip0 <= ~inFlip0;
            inCount <= 0;
         end
         else
            inCount <= inCount + 1;
      end
   end
    assign w_0_0 = {x0, inAddr0};
    assign w_0_1 = {x1, inAddr1};
    assign y0 = z_1_0;
    assign y1 = z_1_1;
    assign u_0_0 = outAddr_a0;
    assign u_0_1 = outAddr_a1;
    wire wr_ctrl_st_0;
    assign wr_ctrl_st_0 = inCount[1];

    switch #(logDepth+width) in_sw_0_0(.x0(w_0_0), .x1(w_0_1), .y0(w_1_0), .y1(w_1_1), .ctrl(wr_ctrl_st_0));
    wire rdd_ctrl_st_0;
    assign rdd_ctrl_st_0 = outCount_for_rd_data[1];

    switch #(width) out_sw_0_0(.x0(z_0_0), .x1(z_0_1), .y0(z_1_0), .y1(z_1_1), .ctrl(rdd_ctrl_st_0));
    wire rda_ctrl_st_0;
    assign rda_ctrl_st_0 = outCount_for_rd_addr[1];

    switch #(logDepth) rdaddr_sw_0_0(.x0(u_0_0), .x1(u_0_1), .y0(u_1_0), .y1(u_1_1), .ctrl(rda_ctrl_st_0));
endmodule

module memArray8_52032(next, reset,
                x0, y0,
                inAddr0,
                outAddr0,
                x1, y1,
                inAddr1,
                outAddr1,
                clk, inFlip, outFlip);

   parameter numBanks = 2;
   parameter logBanks = 1;
   parameter depth = 4;
   parameter logDepth = 2;
   parameter width = 64;
         
   input     clk, next, reset;
   input    inFlip, outFlip;
   wire    next0;
   
   input [width-1:0]   x0;
   output [width-1:0]  y0;
   input [logDepth-1:0] inAddr0, outAddr0;
   input [width-1:0]   x1;
   output [width-1:0]  y1;
   input [logDepth-1:0] inAddr1, outAddr1;
   shiftRegFIFO #(4, 1) shiftFIFO_60001(.X(next), .Y(next0), .clk(clk));


   memMod #(depth*2, width, logDepth+1) 
     memMod0(.in(x0), .out(y0), .inAddr({inFlip, inAddr0}),
	   .outAddr({outFlip, outAddr0}), .writeSel(1'b1), .clk(clk));   
   memMod #(depth*2, width, logDepth+1) 
     memMod1(.in(x1), .out(y1), .inAddr({inFlip, inAddr1}),
	   .outAddr({outFlip, outAddr1}), .writeSel(1'b1), .clk(clk));   
endmodule

// Latency: 12
// Gap: 4
module DirSum_52223(clk, reset, next, next_out,
      X0, Y0,
      X1, Y1,
      X2, Y2,
      X3, Y3);

   output next_out;
   input clk, reset, next;

   reg [1:0] i8;

   input [31:0] X0,
      X1,
      X2,
      X3;

   output [31:0] Y0,
      Y1,
      Y2,
      Y3;

   always @(posedge clk) begin
      if (reset == 1) begin
         i8 <= 0;
      end
      else begin
         if (next == 1)
            i8 <= 0;
         else if (i8 == 3)
            i8 <= 0;
         else
            i8 <= i8 + 1;
      end
   end

   codeBlock52037 codeBlockIsnt60002(.clk(clk), .reset(reset), .next_in(next), .next_out(next_out),
.i8_in(i8),
       .X0_in(X0), .Y0(Y0),
       .X1_in(X1), .Y1(Y1),
       .X2_in(X2), .Y2(Y2),
       .X3_in(X3), .Y3(Y3));

endmodule

module D32_52203(addr, out, clk);
   input clk;
   output [31:0] out;
   reg [31:0] out, out2, out3;
   input [1:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 32'h0;
      1: out3 <= 32'hd2bec333;
      2: out3 <= 32'hc0000000;
      3: out3 <= 32'hd2bec333;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "block"
endmodule



module D30_52215(addr, out, clk);
   input clk;
   output [31:0] out;
   reg [31:0] out, out2, out3;
   input [1:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 32'h40000000;
      1: out3 <= 32'h2d413ccd;
      2: out3 <= 32'h0;
      3: out3 <= 32'hd2bec333;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "block"
endmodule



// Latency: 12
// Gap: 1
module codeBlock52037(clk, reset, next_in, next_out,
   i8_in,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3);

   output next_out;
   input clk, reset, next_in;

   reg next;
   input [1:0] i8_in;
   reg [1:0] i8;

   input [31:0] X0_in,
      X1_in,
      X2_in,
      X3_in;

   reg   [31:0] X0,
      X1,
      X2,
      X3;

   output [31:0] Y0,
      Y1,
      Y2,
      Y3;

   shiftRegFIFO #(11, 1) shiftFIFO_60005(.X(next), .Y(next_out), .clk(clk));


   wire signed [31:0] a474;
   wire signed [31:0] a463;
   wire signed [31:0] a477;
   wire signed [31:0] a467;
   wire signed [31:0] a478;
   wire signed [31:0] a479;
   reg signed [31:0] tm272;
   reg signed [31:0] tm276;
   reg signed [31:0] tm288;
   reg signed [31:0] tm299;
   reg signed [31:0] tm273;
   reg signed [31:0] tm277;
   reg signed [31:0] tm289;
   reg signed [31:0] tm300;
   wire signed [31:0] tm6;
   wire signed [31:0] a468;
   wire signed [31:0] tm7;
   wire signed [31:0] a470;
   reg signed [31:0] tm274;
   reg signed [31:0] tm278;
   reg signed [31:0] tm290;
   reg signed [31:0] tm301;
   reg signed [31:0] tm48;
   reg signed [31:0] tm49;
   reg signed [31:0] tm275;
   reg signed [31:0] tm279;
   reg signed [31:0] tm291;
   reg signed [31:0] tm302;
   reg signed [31:0] tm292;
   reg signed [31:0] tm303;
   reg signed [31:0] tm293;
   reg signed [31:0] tm304;
   reg signed [31:0] tm294;
   reg signed [31:0] tm305;
   reg signed [31:0] tm295;
   reg signed [31:0] tm306;
   reg signed [31:0] tm296;
   reg signed [31:0] tm307;
   wire signed [31:0] a469;
   wire signed [31:0] a471;
   wire signed [31:0] a472;
   wire signed [31:0] a473;
   reg signed [31:0] tm297;
   reg signed [31:0] tm308;
   wire signed [31:0] Y0;
   wire signed [31:0] Y1;
   wire signed [31:0] Y2;
   wire signed [31:0] Y3;
   reg signed [31:0] tm298;
   reg signed [31:0] tm309;


   assign a474 = X0;
   assign a463 = a474;
   assign a477 = X1;
   assign a467 = a477;
   assign a478 = X2;
   assign a479 = X3;
   assign a468 = tm6;
   assign a470 = tm7;
   assign Y0 = tm298;
   assign Y1 = tm309;

   D32_52203 instD32inst0_52203(.addr(i8[1:0]), .out(tm7), .clk(clk));

   D30_52215 instD30inst0_52215(.addr(i8[1:0]), .out(tm6), .clk(clk));

    multfix #(32, 6) m52136(.a(tm48), .b(tm275), .clk(clk), .q_sc(a469), .q_unsc(), .rst(reset));
    multfix #(32, 6) m52158(.a(tm49), .b(tm279), .clk(clk), .q_sc(a471), .q_unsc(), .rst(reset));
    multfix #(32, 6) m52176(.a(tm49), .b(tm275), .clk(clk), .q_sc(a472), .q_unsc(), .rst(reset));
    multfix #(32, 6) m52187(.a(tm48), .b(tm279), .clk(clk), .q_sc(a473), .q_unsc(), .rst(reset));
    subfxp #(32, 1) sub52165(.a(a469), .b(a471), .clk(clk), .q(Y2));    // 10
    addfxp #(32, 1) add52194(.a(a472), .b(a473), .clk(clk), .q(Y3));    // 10


   always @(posedge clk) begin
      if (reset == 1) begin
         tm48 <= 0;
         tm275 <= 0;
         tm49 <= 0;
         tm279 <= 0;
         tm49 <= 0;
         tm275 <= 0;
         tm48 <= 0;
         tm279 <= 0;
      end
      else begin
         i8 <= i8_in;
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         next <= next_in;
         tm272 <= a478;
         tm276 <= a479;
         tm288 <= a463;
         tm299 <= a467;
         tm273 <= tm272;
         tm277 <= tm276;
         tm289 <= tm288;
         tm300 <= tm299;
         tm274 <= tm273;
         tm278 <= tm277;
         tm290 <= tm289;
         tm301 <= tm300;
         tm48 <= a468;
         tm49 <= a470;
         tm275 <= tm274;
         tm279 <= tm278;
         tm291 <= tm290;
         tm302 <= tm301;
         tm292 <= tm291;
         tm303 <= tm302;
         tm293 <= tm292;
         tm304 <= tm303;
         tm294 <= tm293;
         tm305 <= tm304;
         tm295 <= tm294;
         tm306 <= tm305;
         tm296 <= tm295;
         tm307 <= tm306;
         tm297 <= tm296;
         tm308 <= tm307;
         tm298 <= tm297;
         tm309 <= tm308;
      end
   end
endmodule

// Latency: 2
// Gap: 1
module codeBlock52226(clk, reset, next_in, next_out,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3);

   output next_out;
   input clk, reset, next_in;

   reg next;

   input [31:0] X0_in,
      X1_in,
      X2_in,
      X3_in;

   reg   [31:0] X0,
      X1,
      X2,
      X3;

   output [31:0] Y0,
      Y1,
      Y2,
      Y3;

   shiftRegFIFO #(1, 1) shiftFIFO_60008(.X(next), .Y(next_out), .clk(clk));


   wire signed [31:0] a430;
   wire signed [31:0] a431;
   wire signed [31:0] a432;
   wire signed [31:0] a433;
   wire signed [31:0] t189;
   wire signed [31:0] t190;
   wire signed [31:0] t191;
   wire signed [31:0] t192;
   wire signed [31:0] Y0;
   wire signed [31:0] Y1;
   wire signed [31:0] Y2;
   wire signed [31:0] Y3;


   assign a430 = X0;
   assign a431 = X2;
   assign a432 = X1;
   assign a433 = X3;
   assign Y0 = t189;
   assign Y1 = t190;
   assign Y2 = t191;
   assign Y3 = t192;

    addfxp #(32, 1) add52238(.a(a430), .b(a431), .clk(clk), .q(t189));    // 0
    addfxp #(32, 1) add52253(.a(a432), .b(a433), .clk(clk), .q(t190));    // 0
    subfxp #(32, 1) sub52268(.a(a430), .b(a431), .clk(clk), .q(t191));    // 0
    subfxp #(32, 1) sub52283(.a(a432), .b(a433), .clk(clk), .q(t192));    // 0


   always @(posedge clk) begin
      if (reset == 1) begin
      end
      else begin
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         next <= next_in;
      end
   end
endmodule

// Latency: 7
// Gap: 8
module rc52307(clk, reset, next, next_out,
   X0, Y0,
   X1, Y1,
   X2, Y2,
   X3, Y3);

   output next_out;
   input clk, reset, next;

   input [31:0] X0,
      X1,
      X2,
      X3;

   output [31:0] Y0,
      Y1,
      Y2,
      Y3;

   wire [63:0] t0;
   wire [63:0] s0;
   assign t0 = {X0, X1};
   wire [63:0] t1;
   wire [63:0] s1;
   assign t1 = {X2, X3};
   assign Y0 = s0[63:32];
   assign Y1 = s0[31:0];
   assign Y2 = s1[63:32];
   assign Y3 = s1[31:0];

   perm52305 instPerm60009(.x0(t0), .y0(s0),
    .x1(t1), .y1(s1),
   .clk(clk), .next(next), .next_out(next_out), .reset(reset)
);



endmodule

// Latency: 7
// Gap: 8
module perm52305(clk, next, reset, next_out,
   x0, y0,
   x1, y1);
   parameter numBanks = 2;
   parameter logBanks = 1;
   parameter depth = 8;
   parameter logDepth = 3;
   parameter width = 64;

   input [width-1:0]  x0;
   output [width-1:0]  y0;
   wire [width-1:0]  ybuff0;
   input [width-1:0]  x1;
   output [width-1:0]  y1;
   wire [width-1:0]  ybuff1;
   input 	      clk, next, reset;
   output 	     next_out;

   wire    	     next0;

   reg              inFlip0, outFlip0;
   reg              inActive, outActive;

   wire [logBanks-1:0] inBank0, outBank0;
   wire [logDepth-1:0] inAddr0, outAddr0;
   wire [logBanks-1:0] outBank_a0;
   wire [logDepth-1:0] outAddr_a0;
   wire [logDepth+logBanks-1:0] addr0, addr0b, addr0c;
   wire [logBanks-1:0] inBank1, outBank1;
   wire [logDepth-1:0] inAddr1, outAddr1;
   wire [logBanks-1:0] outBank_a1;
   wire [logDepth-1:0] outAddr_a1;
   wire [logDepth+logBanks-1:0] addr1, addr1b, addr1c;


   reg [logDepth-1:0]  inCount, outCount, outCount_d, outCount_dd, outCount_for_rd_addr, outCount_for_rd_data;  

   assign    addr0 = {inCount, 1'd0};
   assign    addr0b = {outCount, 1'd0};
   assign    addr0c = {outCount_for_rd_addr, 1'd0};
   assign    addr1 = {inCount, 1'd1};
   assign    addr1b = {outCount, 1'd1};
   assign    addr1c = {outCount_for_rd_addr, 1'd1};
    wire [width+logDepth-1:0] w_0_0, w_0_1, w_1_0, w_1_1;

    reg [width-1:0] z_0_0;
    reg [width-1:0] z_0_1;
    wire [width-1:0] z_1_0, z_1_1;

    wire [logDepth-1:0] u_0_0, u_0_1, u_1_0, u_1_1;

    always @(posedge clk) begin
    end

   assign inBank0[0] = addr0[3] ^ addr0[0];
   assign inAddr0[0] = addr0[1];
   assign inAddr0[1] = addr0[2];
   assign inAddr0[2] = addr0[0];
   assign outBank0[0] = addr0b[3] ^ addr0b[0];
   assign outAddr0[0] = addr0b[1];
   assign outAddr0[1] = addr0b[2];
   assign outAddr0[2] = addr0b[3];
   assign outBank_a0[0] = addr0c[3] ^ addr0c[0];
   assign outAddr_a0[0] = addr0c[1];
   assign outAddr_a0[1] = addr0c[2];
   assign outAddr_a0[2] = addr0c[3];

   assign inBank1[0] = addr1[3] ^ addr1[0];
   assign inAddr1[0] = addr1[1];
   assign inAddr1[1] = addr1[2];
   assign inAddr1[2] = addr1[0];
   assign outBank1[0] = addr1b[3] ^ addr1b[0];
   assign outAddr1[0] = addr1b[1];
   assign outAddr1[1] = addr1b[2];
   assign outAddr1[2] = addr1b[3];
   assign outBank_a1[0] = addr1c[3] ^ addr1c[0];
   assign outAddr_a1[0] = addr1c[1];
   assign outAddr_a1[1] = addr1c[2];
   assign outAddr_a1[2] = addr1c[3];

   shiftRegFIFO #(5, 1) shiftFIFO_60012(.X(next), .Y(next0), .clk(clk));


   shiftRegFIFO #(2, 1) shiftFIFO_60015(.X(next0), .Y(next_out), .clk(clk));


   memArray16_52305 #(numBanks, logBanks, depth, logDepth, width)
     memSys(.inFlip(inFlip0), .outFlip(outFlip0), .next(next), .reset(reset),
        .x0(w_1_0[width+logDepth-1:logDepth]), .y0(ybuff0),
        .inAddr0(w_1_0[logDepth-1:0]),
        .outAddr0(u_1_0), 
        .x1(w_1_1[width+logDepth-1:logDepth]), .y1(ybuff1),
        .inAddr1(w_1_1[logDepth-1:0]),
        .outAddr1(u_1_1), 
        .clk(clk));

   always @(posedge clk) begin
      if (reset == 1) begin
      z_0_0 <= 0;
      z_0_1 <= 0;
         inFlip0 <= 0; outFlip0 <= 1; outCount <= 0; inCount <= 0;
        outCount_for_rd_addr <= 0;
        outCount_for_rd_data <= 0;
      end
      else begin
          outCount_d <= outCount;
          outCount_dd <= outCount_d;
         if (inCount == 4)
            outCount_for_rd_addr <= 0;
         else
            outCount_for_rd_addr <= outCount_for_rd_addr+1;
         if (inCount == 6)
            outCount_for_rd_data <= 0;
         else
            outCount_for_rd_data <= outCount_for_rd_data+1;
      z_0_0 <= ybuff0;
      z_0_1 <= ybuff1;
         if (inCount == 4) begin
            outFlip0 <= ~outFlip0;
            outCount <= 0;
         end
         else
            outCount <= outCount+1;
         if (inCount == 7) begin
            inFlip0 <= ~inFlip0;
         end
         if (next == 1) begin
            if (inCount >= 4)
               inFlip0 <= ~inFlip0;
            inCount <= 0;
         end
         else
            inCount <= inCount + 1;
      end
   end
    assign w_0_0 = {x0, inAddr0};
    assign w_0_1 = {x1, inAddr1};
    assign y0 = z_1_0;
    assign y1 = z_1_1;
    assign u_0_0 = outAddr_a0;
    assign u_0_1 = outAddr_a1;
    wire wr_ctrl_st_0;
    assign wr_ctrl_st_0 = inCount[2];

    switch #(logDepth+width) in_sw_0_0(.x0(w_0_0), .x1(w_0_1), .y0(w_1_0), .y1(w_1_1), .ctrl(wr_ctrl_st_0));
    wire rdd_ctrl_st_0;
    assign rdd_ctrl_st_0 = outCount_for_rd_data[2];

    switch #(width) out_sw_0_0(.x0(z_0_0), .x1(z_0_1), .y0(z_1_0), .y1(z_1_1), .ctrl(rdd_ctrl_st_0));
    wire rda_ctrl_st_0;
    assign rda_ctrl_st_0 = outCount_for_rd_addr[2];

    switch #(logDepth) rdaddr_sw_0_0(.x0(u_0_0), .x1(u_0_1), .y0(u_1_0), .y1(u_1_1), .ctrl(rda_ctrl_st_0));
endmodule

module memArray16_52305(next, reset,
                x0, y0,
                inAddr0,
                outAddr0,
                x1, y1,
                inAddr1,
                outAddr1,
                clk, inFlip, outFlip);

   parameter numBanks = 2;
   parameter logBanks = 1;
   parameter depth = 8;
   parameter logDepth = 3;
   parameter width = 64;
         
   input     clk, next, reset;
   input    inFlip, outFlip;
   wire    next0;
   
   input [width-1:0]   x0;
   output [width-1:0]  y0;
   input [logDepth-1:0] inAddr0, outAddr0;
   input [width-1:0]   x1;
   output [width-1:0]  y1;
   input [logDepth-1:0] inAddr1, outAddr1;
   shiftRegFIFO #(8, 1) shiftFIFO_60018(.X(next), .Y(next0), .clk(clk));


   memMod #(depth*2, width, logDepth+1) 
     memMod0(.in(x0), .out(y0), .inAddr({inFlip, inAddr0}),
	   .outAddr({outFlip, outAddr0}), .writeSel(1'b1), .clk(clk));   
   memMod #(depth*2, width, logDepth+1) 
     memMod1(.in(x1), .out(y1), .inAddr({inFlip, inAddr1}),
	   .outAddr({outFlip, outAddr1}), .writeSel(1'b1), .clk(clk));   
endmodule

// Latency: 12
// Gap: 8
module DirSum_52512(clk, reset, next, next_out,
      X0, Y0,
      X1, Y1,
      X2, Y2,
      X3, Y3);

   output next_out;
   input clk, reset, next;

   reg [2:0] i7;

   input [31:0] X0,
      X1,
      X2,
      X3;

   output [31:0] Y0,
      Y1,
      Y2,
      Y3;

   always @(posedge clk) begin
      if (reset == 1) begin
         i7 <= 0;
      end
      else begin
         if (next == 1)
            i7 <= 0;
         else if (i7 == 7)
            i7 <= 0;
         else
            i7 <= i7 + 1;
      end
   end

   codeBlock52310 codeBlockIsnt60019(.clk(clk), .reset(reset), .next_in(next), .next_out(next_out),
.i7_in(i7),
       .X0_in(X0), .Y0(Y0),
       .X1_in(X1), .Y1(Y1),
       .X2_in(X2), .Y2(Y2),
       .X3_in(X3), .Y3(Y3));

endmodule

module D28_52480(addr, out, clk);
   input clk;
   output [31:0] out;
   reg [31:0] out, out2, out3;
   input [2:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 32'h0;
      1: out3 <= 32'he7821d59;
      2: out3 <= 32'hd2bec333;
      3: out3 <= 32'hc4df2862;
      4: out3 <= 32'hc0000000;
      5: out3 <= 32'hc4df2862;
      6: out3 <= 32'hd2bec333;
      7: out3 <= 32'he7821d59;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "block"
endmodule



module D26_52500(addr, out, clk);
   input clk;
   output [31:0] out;
   reg [31:0] out, out2, out3;
   input [2:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 32'h40000000;
      1: out3 <= 32'h3b20d79e;
      2: out3 <= 32'h2d413ccd;
      3: out3 <= 32'h187de2a7;
      4: out3 <= 32'h0;
      5: out3 <= 32'he7821d59;
      6: out3 <= 32'hd2bec333;
      7: out3 <= 32'hc4df2862;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "block"
endmodule



// Latency: 12
// Gap: 1
module codeBlock52310(clk, reset, next_in, next_out,
   i7_in,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3);

   output next_out;
   input clk, reset, next_in;

   reg next;
   input [2:0] i7_in;
   reg [2:0] i7;

   input [31:0] X0_in,
      X1_in,
      X2_in,
      X3_in;

   reg   [31:0] X0,
      X1,
      X2,
      X3;

   output [31:0] Y0,
      Y1,
      Y2,
      Y3;

   shiftRegFIFO #(11, 1) shiftFIFO_60022(.X(next), .Y(next_out), .clk(clk));


   wire signed [31:0] a414;
   wire signed [31:0] a403;
   wire signed [31:0] a417;
   wire signed [31:0] a407;
   wire signed [31:0] a418;
   wire signed [31:0] a419;
   reg signed [31:0] tm310;
   reg signed [31:0] tm314;
   reg signed [31:0] tm326;
   reg signed [31:0] tm337;
   reg signed [31:0] tm311;
   reg signed [31:0] tm315;
   reg signed [31:0] tm327;
   reg signed [31:0] tm338;
   wire signed [31:0] tm10;
   wire signed [31:0] a408;
   wire signed [31:0] tm11;
   wire signed [31:0] a410;
   reg signed [31:0] tm312;
   reg signed [31:0] tm316;
   reg signed [31:0] tm328;
   reg signed [31:0] tm339;
   reg signed [31:0] tm56;
   reg signed [31:0] tm57;
   reg signed [31:0] tm313;
   reg signed [31:0] tm317;
   reg signed [31:0] tm329;
   reg signed [31:0] tm340;
   reg signed [31:0] tm330;
   reg signed [31:0] tm341;
   reg signed [31:0] tm331;
   reg signed [31:0] tm342;
   reg signed [31:0] tm332;
   reg signed [31:0] tm343;
   reg signed [31:0] tm333;
   reg signed [31:0] tm344;
   reg signed [31:0] tm334;
   reg signed [31:0] tm345;
   wire signed [31:0] a409;
   wire signed [31:0] a411;
   wire signed [31:0] a412;
   wire signed [31:0] a413;
   reg signed [31:0] tm335;
   reg signed [31:0] tm346;
   wire signed [31:0] Y0;
   wire signed [31:0] Y1;
   wire signed [31:0] Y2;
   wire signed [31:0] Y3;
   reg signed [31:0] tm336;
   reg signed [31:0] tm347;


   assign a414 = X0;
   assign a403 = a414;
   assign a417 = X1;
   assign a407 = a417;
   assign a418 = X2;
   assign a419 = X3;
   assign a408 = tm10;
   assign a410 = tm11;
   assign Y0 = tm336;
   assign Y1 = tm347;

   D28_52480 instD28inst0_52480(.addr(i7[2:0]), .out(tm11), .clk(clk));

   D26_52500 instD26inst0_52500(.addr(i7[2:0]), .out(tm10), .clk(clk));

    multfix #(32, 6) m52409(.a(tm56), .b(tm313), .clk(clk), .q_sc(a409), .q_unsc(), .rst(reset));
    multfix #(32, 6) m52431(.a(tm57), .b(tm317), .clk(clk), .q_sc(a411), .q_unsc(), .rst(reset));
    multfix #(32, 6) m52449(.a(tm57), .b(tm313), .clk(clk), .q_sc(a412), .q_unsc(), .rst(reset));
    multfix #(32, 6) m52460(.a(tm56), .b(tm317), .clk(clk), .q_sc(a413), .q_unsc(), .rst(reset));
    subfxp #(32, 1) sub52438(.a(a409), .b(a411), .clk(clk), .q(Y2));    // 10
    addfxp #(32, 1) add52467(.a(a412), .b(a413), .clk(clk), .q(Y3));    // 10


   always @(posedge clk) begin
      if (reset == 1) begin
         tm56 <= 0;
         tm313 <= 0;
         tm57 <= 0;
         tm317 <= 0;
         tm57 <= 0;
         tm313 <= 0;
         tm56 <= 0;
         tm317 <= 0;
      end
      else begin
         i7 <= i7_in;
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         next <= next_in;
         tm310 <= a418;
         tm314 <= a419;
         tm326 <= a403;
         tm337 <= a407;
         tm311 <= tm310;
         tm315 <= tm314;
         tm327 <= tm326;
         tm338 <= tm337;
         tm312 <= tm311;
         tm316 <= tm315;
         tm328 <= tm327;
         tm339 <= tm338;
         tm56 <= a408;
         tm57 <= a410;
         tm313 <= tm312;
         tm317 <= tm316;
         tm329 <= tm328;
         tm340 <= tm339;
         tm330 <= tm329;
         tm341 <= tm340;
         tm331 <= tm330;
         tm342 <= tm341;
         tm332 <= tm331;
         tm343 <= tm342;
         tm333 <= tm332;
         tm344 <= tm343;
         tm334 <= tm333;
         tm345 <= tm344;
         tm335 <= tm334;
         tm346 <= tm345;
         tm336 <= tm335;
         tm347 <= tm346;
      end
   end
endmodule

// Latency: 2
// Gap: 1
module codeBlock52515(clk, reset, next_in, next_out,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3);

   output next_out;
   input clk, reset, next_in;

   reg next;

   input [31:0] X0_in,
      X1_in,
      X2_in,
      X3_in;

   reg   [31:0] X0,
      X1,
      X2,
      X3;

   output [31:0] Y0,
      Y1,
      Y2,
      Y3;

   shiftRegFIFO #(1, 1) shiftFIFO_60025(.X(next), .Y(next_out), .clk(clk));


   wire signed [31:0] a369;
   wire signed [31:0] a370;
   wire signed [31:0] a371;
   wire signed [31:0] a372;
   wire signed [31:0] t165;
   wire signed [31:0] t166;
   wire signed [31:0] t167;
   wire signed [31:0] t168;
   wire signed [31:0] Y0;
   wire signed [31:0] Y1;
   wire signed [31:0] Y2;
   wire signed [31:0] Y3;


   assign a369 = X0;
   assign a370 = X2;
   assign a371 = X1;
   assign a372 = X3;
   assign Y0 = t165;
   assign Y1 = t166;
   assign Y2 = t167;
   assign Y3 = t168;

    addfxp #(32, 1) add52527(.a(a369), .b(a370), .clk(clk), .q(t165));    // 0
    addfxp #(32, 1) add52542(.a(a371), .b(a372), .clk(clk), .q(t166));    // 0
    subfxp #(32, 1) sub52557(.a(a369), .b(a370), .clk(clk), .q(t167));    // 0
    subfxp #(32, 1) sub52572(.a(a371), .b(a372), .clk(clk), .q(t168));    // 0


   always @(posedge clk) begin
      if (reset == 1) begin
      end
      else begin
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         next <= next_in;
      end
   end
endmodule

// Latency: 11
// Gap: 16
module rc52596(clk, reset, next, next_out,
   X0, Y0,
   X1, Y1,
   X2, Y2,
   X3, Y3);

   output next_out;
   input clk, reset, next;

   input [31:0] X0,
      X1,
      X2,
      X3;

   output [31:0] Y0,
      Y1,
      Y2,
      Y3;

   wire [63:0] t0;
   wire [63:0] s0;
   assign t0 = {X0, X1};
   wire [63:0] t1;
   wire [63:0] s1;
   assign t1 = {X2, X3};
   assign Y0 = s0[63:32];
   assign Y1 = s0[31:0];
   assign Y2 = s1[63:32];
   assign Y3 = s1[31:0];

   perm52594 instPerm60026(.x0(t0), .y0(s0),
    .x1(t1), .y1(s1),
   .clk(clk), .next(next), .next_out(next_out), .reset(reset)
);



endmodule

// Latency: 11
// Gap: 16
module perm52594(clk, next, reset, next_out,
   x0, y0,
   x1, y1);
   parameter numBanks = 2;
   parameter logBanks = 1;
   parameter depth = 16;
   parameter logDepth = 4;
   parameter width = 64;

   input [width-1:0]  x0;
   output [width-1:0]  y0;
   wire [width-1:0]  ybuff0;
   input [width-1:0]  x1;
   output [width-1:0]  y1;
   wire [width-1:0]  ybuff1;
   input 	      clk, next, reset;
   output 	     next_out;

   wire    	     next0;

   reg              inFlip0, outFlip0;
   reg              inActive, outActive;

   wire [logBanks-1:0] inBank0, outBank0;
   wire [logDepth-1:0] inAddr0, outAddr0;
   wire [logBanks-1:0] outBank_a0;
   wire [logDepth-1:0] outAddr_a0;
   wire [logDepth+logBanks-1:0] addr0, addr0b, addr0c;
   wire [logBanks-1:0] inBank1, outBank1;
   wire [logDepth-1:0] inAddr1, outAddr1;
   wire [logBanks-1:0] outBank_a1;
   wire [logDepth-1:0] outAddr_a1;
   wire [logDepth+logBanks-1:0] addr1, addr1b, addr1c;


   reg [logDepth-1:0]  inCount, outCount, outCount_d, outCount_dd, outCount_for_rd_addr, outCount_for_rd_data;  

   assign    addr0 = {inCount, 1'd0};
   assign    addr0b = {outCount, 1'd0};
   assign    addr0c = {outCount_for_rd_addr, 1'd0};
   assign    addr1 = {inCount, 1'd1};
   assign    addr1b = {outCount, 1'd1};
   assign    addr1c = {outCount_for_rd_addr, 1'd1};
    wire [width+logDepth-1:0] w_0_0, w_0_1, w_1_0, w_1_1;

    reg [width-1:0] z_0_0;
    reg [width-1:0] z_0_1;
    wire [width-1:0] z_1_0, z_1_1;

    wire [logDepth-1:0] u_0_0, u_0_1, u_1_0, u_1_1;

    always @(posedge clk) begin
    end

   assign inBank0[0] = addr0[4] ^ addr0[0];
   assign inAddr0[0] = addr0[1];
   assign inAddr0[1] = addr0[2];
   assign inAddr0[2] = addr0[3];
   assign inAddr0[3] = addr0[0];
   assign outBank0[0] = addr0b[4] ^ addr0b[0];
   assign outAddr0[0] = addr0b[1];
   assign outAddr0[1] = addr0b[2];
   assign outAddr0[2] = addr0b[3];
   assign outAddr0[3] = addr0b[4];
   assign outBank_a0[0] = addr0c[4] ^ addr0c[0];
   assign outAddr_a0[0] = addr0c[1];
   assign outAddr_a0[1] = addr0c[2];
   assign outAddr_a0[2] = addr0c[3];
   assign outAddr_a0[3] = addr0c[4];

   assign inBank1[0] = addr1[4] ^ addr1[0];
   assign inAddr1[0] = addr1[1];
   assign inAddr1[1] = addr1[2];
   assign inAddr1[2] = addr1[3];
   assign inAddr1[3] = addr1[0];
   assign outBank1[0] = addr1b[4] ^ addr1b[0];
   assign outAddr1[0] = addr1b[1];
   assign outAddr1[1] = addr1b[2];
   assign outAddr1[2] = addr1b[3];
   assign outAddr1[3] = addr1b[4];
   assign outBank_a1[0] = addr1c[4] ^ addr1c[0];
   assign outAddr_a1[0] = addr1c[1];
   assign outAddr_a1[1] = addr1c[2];
   assign outAddr_a1[2] = addr1c[3];
   assign outAddr_a1[3] = addr1c[4];

   nextReg #(9, 4) nextReg_60031(.X(next), .Y(next0), .reset(reset), .clk(clk));


   shiftRegFIFO #(2, 1) shiftFIFO_60034(.X(next0), .Y(next_out), .clk(clk));


   memArray32_52594 #(numBanks, logBanks, depth, logDepth, width)
     memSys(.inFlip(inFlip0), .outFlip(outFlip0), .next(next), .reset(reset),
        .x0(w_1_0[width+logDepth-1:logDepth]), .y0(ybuff0),
        .inAddr0(w_1_0[logDepth-1:0]),
        .outAddr0(u_1_0), 
        .x1(w_1_1[width+logDepth-1:logDepth]), .y1(ybuff1),
        .inAddr1(w_1_1[logDepth-1:0]),
        .outAddr1(u_1_1), 
        .clk(clk));

   always @(posedge clk) begin
      if (reset == 1) begin
      z_0_0 <= 0;
      z_0_1 <= 0;
         inFlip0 <= 0; outFlip0 <= 1; outCount <= 0; inCount <= 0;
        outCount_for_rd_addr <= 0;
        outCount_for_rd_data <= 0;
      end
      else begin
          outCount_d <= outCount;
          outCount_dd <= outCount_d;
         if (inCount == 8)
            outCount_for_rd_addr <= 0;
         else
            outCount_for_rd_addr <= outCount_for_rd_addr+1;
         if (inCount == 10)
            outCount_for_rd_data <= 0;
         else
            outCount_for_rd_data <= outCount_for_rd_data+1;
      z_0_0 <= ybuff0;
      z_0_1 <= ybuff1;
         if (inCount == 8) begin
            outFlip0 <= ~outFlip0;
            outCount <= 0;
         end
         else
            outCount <= outCount+1;
         if (inCount == 15) begin
            inFlip0 <= ~inFlip0;
         end
         if (next == 1) begin
            if (inCount >= 8)
               inFlip0 <= ~inFlip0;
            inCount <= 0;
         end
         else
            inCount <= inCount + 1;
      end
   end
    assign w_0_0 = {x0, inAddr0};
    assign w_0_1 = {x1, inAddr1};
    assign y0 = z_1_0;
    assign y1 = z_1_1;
    assign u_0_0 = outAddr_a0;
    assign u_0_1 = outAddr_a1;
    wire wr_ctrl_st_0;
    assign wr_ctrl_st_0 = inCount[3];

    switch #(logDepth+width) in_sw_0_0(.x0(w_0_0), .x1(w_0_1), .y0(w_1_0), .y1(w_1_1), .ctrl(wr_ctrl_st_0));
    wire rdd_ctrl_st_0;
    assign rdd_ctrl_st_0 = outCount_for_rd_data[3];

    switch #(width) out_sw_0_0(.x0(z_0_0), .x1(z_0_1), .y0(z_1_0), .y1(z_1_1), .ctrl(rdd_ctrl_st_0));
    wire rda_ctrl_st_0;
    assign rda_ctrl_st_0 = outCount_for_rd_addr[3];

    switch #(logDepth) rdaddr_sw_0_0(.x0(u_0_0), .x1(u_0_1), .y0(u_1_0), .y1(u_1_1), .ctrl(rda_ctrl_st_0));
endmodule

module memArray32_52594(next, reset,
                x0, y0,
                inAddr0,
                outAddr0,
                x1, y1,
                inAddr1,
                outAddr1,
                clk, inFlip, outFlip);

   parameter numBanks = 2;
   parameter logBanks = 1;
   parameter depth = 16;
   parameter logDepth = 4;
   parameter width = 64;
         
   input     clk, next, reset;
   input    inFlip, outFlip;
   wire    next0;
   
   input [width-1:0]   x0;
   output [width-1:0]  y0;
   input [logDepth-1:0] inAddr0, outAddr0;
   input [width-1:0]   x1;
   output [width-1:0]  y1;
   input [logDepth-1:0] inAddr1, outAddr1;
   nextReg #(16, 4) nextReg_60039(.X(next), .Y(next0), .reset(reset), .clk(clk));


   memMod #(depth*2, width, logDepth+1) 
     memMod0(.in(x0), .out(y0), .inAddr({inFlip, inAddr0}),
	   .outAddr({outFlip, outAddr0}), .writeSel(1'b1), .clk(clk));   
   memMod #(depth*2, width, logDepth+1) 
     memMod1(.in(x1), .out(y1), .inAddr({inFlip, inAddr1}),
	   .outAddr({outFlip, outAddr1}), .writeSel(1'b1), .clk(clk));   
endmodule

// Latency: 12
// Gap: 16
module DirSum_52833(clk, reset, next, next_out,
      X0, Y0,
      X1, Y1,
      X2, Y2,
      X3, Y3);

   output next_out;
   input clk, reset, next;

   reg [3:0] i6;

   input [31:0] X0,
      X1,
      X2,
      X3;

   output [31:0] Y0,
      Y1,
      Y2,
      Y3;

   always @(posedge clk) begin
      if (reset == 1) begin
         i6 <= 0;
      end
      else begin
         if (next == 1)
            i6 <= 0;
         else if (i6 == 15)
            i6 <= 0;
         else
            i6 <= i6 + 1;
      end
   end

   codeBlock52599 codeBlockIsnt60044(.clk(clk), .reset(reset), .next_in(next), .next_out(next_out),
.i6_in(i6),
       .X0_in(X0), .Y0(Y0),
       .X1_in(X1), .Y1(Y1),
       .X2_in(X2), .Y2(Y2),
       .X3_in(X3), .Y3(Y3));

endmodule

module D24_52777(addr, out, clk);
   input clk;
   output [31:0] out;
   reg [31:0] out, out2, out3;
   input [3:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 32'h0;
      1: out3 <= 32'hf383a3e2;
      2: out3 <= 32'he7821d59;
      3: out3 <= 32'hdc71898d;
      4: out3 <= 32'hd2bec333;
      5: out3 <= 32'hcac933ae;
      6: out3 <= 32'hc4df2862;
      7: out3 <= 32'hc13ad060;
      8: out3 <= 32'hc0000000;
      9: out3 <= 32'hc13ad060;
      10: out3 <= 32'hc4df2862;
      11: out3 <= 32'hcac933ae;
      12: out3 <= 32'hd2bec333;
      13: out3 <= 32'hdc71898d;
      14: out3 <= 32'he7821d59;
      15: out3 <= 32'hf383a3e2;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "block"
endmodule



module D22_52813(addr, out, clk);
   input clk;
   output [31:0] out;
   reg [31:0] out, out2, out3;
   input [3:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 32'h40000000;
      1: out3 <= 32'h3ec52fa0;
      2: out3 <= 32'h3b20d79e;
      3: out3 <= 32'h3536cc52;
      4: out3 <= 32'h2d413ccd;
      5: out3 <= 32'h238e7673;
      6: out3 <= 32'h187de2a7;
      7: out3 <= 32'hc7c5c1e;
      8: out3 <= 32'h0;
      9: out3 <= 32'hf383a3e2;
      10: out3 <= 32'he7821d59;
      11: out3 <= 32'hdc71898d;
      12: out3 <= 32'hd2bec333;
      13: out3 <= 32'hcac933ae;
      14: out3 <= 32'hc4df2862;
      15: out3 <= 32'hc13ad060;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "block"
endmodule



// Latency: 12
// Gap: 1
module codeBlock52599(clk, reset, next_in, next_out,
   i6_in,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3);

   output next_out;
   input clk, reset, next_in;

   reg next;
   input [3:0] i6_in;
   reg [3:0] i6;

   input [31:0] X0_in,
      X1_in,
      X2_in,
      X3_in;

   reg   [31:0] X0,
      X1,
      X2,
      X3;

   output [31:0] Y0,
      Y1,
      Y2,
      Y3;

   shiftRegFIFO #(11, 1) shiftFIFO_60047(.X(next), .Y(next_out), .clk(clk));


   wire signed [31:0] a353;
   wire signed [31:0] a342;
   wire signed [31:0] a356;
   wire signed [31:0] a346;
   wire signed [31:0] a357;
   wire signed [31:0] a358;
   reg signed [31:0] tm348;
   reg signed [31:0] tm352;
   reg signed [31:0] tm364;
   reg signed [31:0] tm375;
   reg signed [31:0] tm349;
   reg signed [31:0] tm353;
   reg signed [31:0] tm365;
   reg signed [31:0] tm376;
   wire signed [31:0] tm14;
   wire signed [31:0] a347;
   wire signed [31:0] tm15;
   wire signed [31:0] a349;
   reg signed [31:0] tm350;
   reg signed [31:0] tm354;
   reg signed [31:0] tm366;
   reg signed [31:0] tm377;
   reg signed [31:0] tm64;
   reg signed [31:0] tm65;
   reg signed [31:0] tm351;
   reg signed [31:0] tm355;
   reg signed [31:0] tm367;
   reg signed [31:0] tm378;
   reg signed [31:0] tm368;
   reg signed [31:0] tm379;
   reg signed [31:0] tm369;
   reg signed [31:0] tm380;
   reg signed [31:0] tm370;
   reg signed [31:0] tm381;
   reg signed [31:0] tm371;
   reg signed [31:0] tm382;
   reg signed [31:0] tm372;
   reg signed [31:0] tm383;
   wire signed [31:0] a348;
   wire signed [31:0] a350;
   wire signed [31:0] a351;
   wire signed [31:0] a352;
   reg signed [31:0] tm373;
   reg signed [31:0] tm384;
   wire signed [31:0] Y0;
   wire signed [31:0] Y1;
   wire signed [31:0] Y2;
   wire signed [31:0] Y3;
   reg signed [31:0] tm374;
   reg signed [31:0] tm385;


   assign a353 = X0;
   assign a342 = a353;
   assign a356 = X1;
   assign a346 = a356;
   assign a357 = X2;
   assign a358 = X3;
   assign a347 = tm14;
   assign a349 = tm15;
   assign Y0 = tm374;
   assign Y1 = tm385;

   D24_52777 instD24inst0_52777(.addr(i6[3:0]), .out(tm15), .clk(clk));

   D22_52813 instD22inst0_52813(.addr(i6[3:0]), .out(tm14), .clk(clk));

    multfix #(32, 6) m52698(.a(tm64), .b(tm351), .clk(clk), .q_sc(a348), .q_unsc(), .rst(reset));
    multfix #(32, 6) m52720(.a(tm65), .b(tm355), .clk(clk), .q_sc(a350), .q_unsc(), .rst(reset));
    multfix #(32, 6) m52738(.a(tm65), .b(tm351), .clk(clk), .q_sc(a351), .q_unsc(), .rst(reset));
    multfix #(32, 6) m52749(.a(tm64), .b(tm355), .clk(clk), .q_sc(a352), .q_unsc(), .rst(reset));
    subfxp #(32, 1) sub52727(.a(a348), .b(a350), .clk(clk), .q(Y2));    // 10
    addfxp #(32, 1) add52756(.a(a351), .b(a352), .clk(clk), .q(Y3));    // 10


   always @(posedge clk) begin
      if (reset == 1) begin
         tm64 <= 0;
         tm351 <= 0;
         tm65 <= 0;
         tm355 <= 0;
         tm65 <= 0;
         tm351 <= 0;
         tm64 <= 0;
         tm355 <= 0;
      end
      else begin
         i6 <= i6_in;
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         next <= next_in;
         tm348 <= a357;
         tm352 <= a358;
         tm364 <= a342;
         tm375 <= a346;
         tm349 <= tm348;
         tm353 <= tm352;
         tm365 <= tm364;
         tm376 <= tm375;
         tm350 <= tm349;
         tm354 <= tm353;
         tm366 <= tm365;
         tm377 <= tm376;
         tm64 <= a347;
         tm65 <= a349;
         tm351 <= tm350;
         tm355 <= tm354;
         tm367 <= tm366;
         tm378 <= tm377;
         tm368 <= tm367;
         tm379 <= tm378;
         tm369 <= tm368;
         tm380 <= tm379;
         tm370 <= tm369;
         tm381 <= tm380;
         tm371 <= tm370;
         tm382 <= tm381;
         tm372 <= tm371;
         tm383 <= tm382;
         tm373 <= tm372;
         tm384 <= tm383;
         tm374 <= tm373;
         tm385 <= tm384;
      end
   end
endmodule

// Latency: 2
// Gap: 1
module codeBlock52836(clk, reset, next_in, next_out,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3);

   output next_out;
   input clk, reset, next_in;

   reg next;

   input [31:0] X0_in,
      X1_in,
      X2_in,
      X3_in;

   reg   [31:0] X0,
      X1,
      X2,
      X3;

   output [31:0] Y0,
      Y1,
      Y2,
      Y3;

   shiftRegFIFO #(1, 1) shiftFIFO_60050(.X(next), .Y(next_out), .clk(clk));


   wire signed [31:0] a309;
   wire signed [31:0] a310;
   wire signed [31:0] a311;
   wire signed [31:0] a312;
   wire signed [31:0] t141;
   wire signed [31:0] t142;
   wire signed [31:0] t143;
   wire signed [31:0] t144;
   wire signed [31:0] Y0;
   wire signed [31:0] Y1;
   wire signed [31:0] Y2;
   wire signed [31:0] Y3;


   assign a309 = X0;
   assign a310 = X2;
   assign a311 = X1;
   assign a312 = X3;
   assign Y0 = t141;
   assign Y1 = t142;
   assign Y2 = t143;
   assign Y3 = t144;

    addfxp #(32, 1) add52848(.a(a309), .b(a310), .clk(clk), .q(t141));    // 0
    addfxp #(32, 1) add52863(.a(a311), .b(a312), .clk(clk), .q(t142));    // 0
    subfxp #(32, 1) sub52878(.a(a309), .b(a310), .clk(clk), .q(t143));    // 0
    subfxp #(32, 1) sub52893(.a(a311), .b(a312), .clk(clk), .q(t144));    // 0


   always @(posedge clk) begin
      if (reset == 1) begin
      end
      else begin
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         next <= next_in;
      end
   end
endmodule

// Latency: 19
// Gap: 32
module rc52917(clk, reset, next, next_out,
   X0, Y0,
   X1, Y1,
   X2, Y2,
   X3, Y3);

   output next_out;
   input clk, reset, next;

   input [31:0] X0,
      X1,
      X2,
      X3;

   output [31:0] Y0,
      Y1,
      Y2,
      Y3;

   wire [63:0] t0;
   wire [63:0] s0;
   assign t0 = {X0, X1};
   wire [63:0] t1;
   wire [63:0] s1;
   assign t1 = {X2, X3};
   assign Y0 = s0[63:32];
   assign Y1 = s0[31:0];
   assign Y2 = s1[63:32];
   assign Y3 = s1[31:0];

   perm52915 instPerm60051(.x0(t0), .y0(s0),
    .x1(t1), .y1(s1),
   .clk(clk), .next(next), .next_out(next_out), .reset(reset)
);



endmodule

// Latency: 19
// Gap: 32
module perm52915(clk, next, reset, next_out,
   x0, y0,
   x1, y1);
   parameter numBanks = 2;
   parameter logBanks = 1;
   parameter depth = 32;
   parameter logDepth = 5;
   parameter width = 64;

   input [width-1:0]  x0;
   output [width-1:0]  y0;
   wire [width-1:0]  ybuff0;
   input [width-1:0]  x1;
   output [width-1:0]  y1;
   wire [width-1:0]  ybuff1;
   input 	      clk, next, reset;
   output 	     next_out;

   wire    	     next0;

   reg              inFlip0, outFlip0;
   reg              inActive, outActive;

   wire [logBanks-1:0] inBank0, outBank0;
   wire [logDepth-1:0] inAddr0, outAddr0;
   wire [logBanks-1:0] outBank_a0;
   wire [logDepth-1:0] outAddr_a0;
   wire [logDepth+logBanks-1:0] addr0, addr0b, addr0c;
   wire [logBanks-1:0] inBank1, outBank1;
   wire [logDepth-1:0] inAddr1, outAddr1;
   wire [logBanks-1:0] outBank_a1;
   wire [logDepth-1:0] outAddr_a1;
   wire [logDepth+logBanks-1:0] addr1, addr1b, addr1c;


   reg [logDepth-1:0]  inCount, outCount, outCount_d, outCount_dd, outCount_for_rd_addr, outCount_for_rd_data;  

   assign    addr0 = {inCount, 1'd0};
   assign    addr0b = {outCount, 1'd0};
   assign    addr0c = {outCount_for_rd_addr, 1'd0};
   assign    addr1 = {inCount, 1'd1};
   assign    addr1b = {outCount, 1'd1};
   assign    addr1c = {outCount_for_rd_addr, 1'd1};
    wire [width+logDepth-1:0] w_0_0, w_0_1, w_1_0, w_1_1;

    reg [width-1:0] z_0_0;
    reg [width-1:0] z_0_1;
    wire [width-1:0] z_1_0, z_1_1;

    wire [logDepth-1:0] u_0_0, u_0_1, u_1_0, u_1_1;

    always @(posedge clk) begin
    end

   assign inBank0[0] = addr0[5] ^ addr0[0];
   assign inAddr0[0] = addr0[1];
   assign inAddr0[1] = addr0[2];
   assign inAddr0[2] = addr0[3];
   assign inAddr0[3] = addr0[4];
   assign inAddr0[4] = addr0[0];
   assign outBank0[0] = addr0b[5] ^ addr0b[0];
   assign outAddr0[0] = addr0b[1];
   assign outAddr0[1] = addr0b[2];
   assign outAddr0[2] = addr0b[3];
   assign outAddr0[3] = addr0b[4];
   assign outAddr0[4] = addr0b[5];
   assign outBank_a0[0] = addr0c[5] ^ addr0c[0];
   assign outAddr_a0[0] = addr0c[1];
   assign outAddr_a0[1] = addr0c[2];
   assign outAddr_a0[2] = addr0c[3];
   assign outAddr_a0[3] = addr0c[4];
   assign outAddr_a0[4] = addr0c[5];

   assign inBank1[0] = addr1[5] ^ addr1[0];
   assign inAddr1[0] = addr1[1];
   assign inAddr1[1] = addr1[2];
   assign inAddr1[2] = addr1[3];
   assign inAddr1[3] = addr1[4];
   assign inAddr1[4] = addr1[0];
   assign outBank1[0] = addr1b[5] ^ addr1b[0];
   assign outAddr1[0] = addr1b[1];
   assign outAddr1[1] = addr1b[2];
   assign outAddr1[2] = addr1b[3];
   assign outAddr1[3] = addr1b[4];
   assign outAddr1[4] = addr1b[5];
   assign outBank_a1[0] = addr1c[5] ^ addr1c[0];
   assign outAddr_a1[0] = addr1c[1];
   assign outAddr_a1[1] = addr1c[2];
   assign outAddr_a1[2] = addr1c[3];
   assign outAddr_a1[3] = addr1c[4];
   assign outAddr_a1[4] = addr1c[5];

   nextReg #(17, 5) nextReg_60056(.X(next), .Y(next0), .reset(reset), .clk(clk));


   shiftRegFIFO #(2, 1) shiftFIFO_60059(.X(next0), .Y(next_out), .clk(clk));


   memArray64_52915 #(numBanks, logBanks, depth, logDepth, width)
     memSys(.inFlip(inFlip0), .outFlip(outFlip0), .next(next), .reset(reset),
        .x0(w_1_0[width+logDepth-1:logDepth]), .y0(ybuff0),
        .inAddr0(w_1_0[logDepth-1:0]),
        .outAddr0(u_1_0), 
        .x1(w_1_1[width+logDepth-1:logDepth]), .y1(ybuff1),
        .inAddr1(w_1_1[logDepth-1:0]),
        .outAddr1(u_1_1), 
        .clk(clk));

   always @(posedge clk) begin
      if (reset == 1) begin
      z_0_0 <= 0;
      z_0_1 <= 0;
         inFlip0 <= 0; outFlip0 <= 1; outCount <= 0; inCount <= 0;
        outCount_for_rd_addr <= 0;
        outCount_for_rd_data <= 0;
      end
      else begin
          outCount_d <= outCount;
          outCount_dd <= outCount_d;
         if (inCount == 16)
            outCount_for_rd_addr <= 0;
         else
            outCount_for_rd_addr <= outCount_for_rd_addr+1;
         if (inCount == 18)
            outCount_for_rd_data <= 0;
         else
            outCount_for_rd_data <= outCount_for_rd_data+1;
      z_0_0 <= ybuff0;
      z_0_1 <= ybuff1;
         if (inCount == 16) begin
            outFlip0 <= ~outFlip0;
            outCount <= 0;
         end
         else
            outCount <= outCount+1;
         if (inCount == 31) begin
            inFlip0 <= ~inFlip0;
         end
         if (next == 1) begin
            if (inCount >= 16)
               inFlip0 <= ~inFlip0;
            inCount <= 0;
         end
         else
            inCount <= inCount + 1;
      end
   end
    assign w_0_0 = {x0, inAddr0};
    assign w_0_1 = {x1, inAddr1};
    assign y0 = z_1_0;
    assign y1 = z_1_1;
    assign u_0_0 = outAddr_a0;
    assign u_0_1 = outAddr_a1;
    wire wr_ctrl_st_0;
    assign wr_ctrl_st_0 = inCount[4];

    switch #(logDepth+width) in_sw_0_0(.x0(w_0_0), .x1(w_0_1), .y0(w_1_0), .y1(w_1_1), .ctrl(wr_ctrl_st_0));
    wire rdd_ctrl_st_0;
    assign rdd_ctrl_st_0 = outCount_for_rd_data[4];

    switch #(width) out_sw_0_0(.x0(z_0_0), .x1(z_0_1), .y0(z_1_0), .y1(z_1_1), .ctrl(rdd_ctrl_st_0));
    wire rda_ctrl_st_0;
    assign rda_ctrl_st_0 = outCount_for_rd_addr[4];

    switch #(logDepth) rdaddr_sw_0_0(.x0(u_0_0), .x1(u_0_1), .y0(u_1_0), .y1(u_1_1), .ctrl(rda_ctrl_st_0));
endmodule

module memArray64_52915(next, reset,
                x0, y0,
                inAddr0,
                outAddr0,
                x1, y1,
                inAddr1,
                outAddr1,
                clk, inFlip, outFlip);

   parameter numBanks = 2;
   parameter logBanks = 1;
   parameter depth = 32;
   parameter logDepth = 5;
   parameter width = 64;
         
   input     clk, next, reset;
   input    inFlip, outFlip;
   wire    next0;
   
   input [width-1:0]   x0;
   output [width-1:0]  y0;
   input [logDepth-1:0] inAddr0, outAddr0;
   input [width-1:0]   x1;
   output [width-1:0]  y1;
   input [logDepth-1:0] inAddr1, outAddr1;
   nextReg #(32, 5) nextReg_60064(.X(next), .Y(next0), .reset(reset), .clk(clk));


   memMod #(depth*2, width, logDepth+1) 
     memMod0(.in(x0), .out(y0), .inAddr({inFlip, inAddr0}),
	   .outAddr({outFlip, outAddr0}), .writeSel(1'b1), .clk(clk));   
   memMod #(depth*2, width, logDepth+1) 
     memMod1(.in(x1), .out(y1), .inAddr({inFlip, inAddr1}),
	   .outAddr({outFlip, outAddr1}), .writeSel(1'b1), .clk(clk));   
endmodule

// Latency: 12
// Gap: 32
module DirSum_53218(clk, reset, next, next_out,
      X0, Y0,
      X1, Y1,
      X2, Y2,
      X3, Y3);

   output next_out;
   input clk, reset, next;

   reg [4:0] i5;

   input [31:0] X0,
      X1,
      X2,
      X3;

   output [31:0] Y0,
      Y1,
      Y2,
      Y3;

   always @(posedge clk) begin
      if (reset == 1) begin
         i5 <= 0;
      end
      else begin
         if (next == 1)
            i5 <= 0;
         else if (i5 == 31)
            i5 <= 0;
         else
            i5 <= i5 + 1;
      end
   end

   codeBlock52920 codeBlockIsnt60069(.clk(clk), .reset(reset), .next_in(next), .next_out(next_out),
.i5_in(i5),
       .X0_in(X0), .Y0(Y0),
       .X1_in(X1), .Y1(Y1),
       .X2_in(X2), .Y2(Y2),
       .X3_in(X3), .Y3(Y3));

endmodule

module D20_53114(addr, out, clk);
   input clk;
   output [31:0] out;
   reg [31:0] out, out2, out3;
   input [4:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 32'h0;
      1: out3 <= 32'hf9ba1651;
      2: out3 <= 32'hf383a3e2;
      3: out3 <= 32'hed6bf9d1;
      4: out3 <= 32'he7821d59;
      5: out3 <= 32'he1d4a2c8;
      6: out3 <= 32'hdc71898d;
      7: out3 <= 32'hd76619b6;
      8: out3 <= 32'hd2bec333;
      9: out3 <= 32'hce86ff2a;
      10: out3 <= 32'hcac933ae;
      11: out3 <= 32'hc78e9a1d;
      12: out3 <= 32'hc4df2862;
      13: out3 <= 32'hc2c17d52;
      14: out3 <= 32'hc13ad060;
      15: out3 <= 32'hc04ee4b8;
      16: out3 <= 32'hc0000000;
      17: out3 <= 32'hc04ee4b8;
      18: out3 <= 32'hc13ad060;
      19: out3 <= 32'hc2c17d52;
      20: out3 <= 32'hc4df2862;
      21: out3 <= 32'hc78e9a1d;
      22: out3 <= 32'hcac933ae;
      23: out3 <= 32'hce86ff2a;
      24: out3 <= 32'hd2bec333;
      25: out3 <= 32'hd76619b6;
      26: out3 <= 32'hdc71898d;
      27: out3 <= 32'he1d4a2c8;
      28: out3 <= 32'he7821d59;
      29: out3 <= 32'hed6bf9d1;
      30: out3 <= 32'hf383a3e2;
      31: out3 <= 32'hf9ba1651;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "block"
endmodule



module D18_53182(addr, out, clk);
   input clk;
   output [31:0] out;
   reg [31:0] out, out2, out3;
   input [4:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 32'h40000000;
      1: out3 <= 32'h3fb11b48;
      2: out3 <= 32'h3ec52fa0;
      3: out3 <= 32'h3d3e82ae;
      4: out3 <= 32'h3b20d79e;
      5: out3 <= 32'h387165e3;
      6: out3 <= 32'h3536cc52;
      7: out3 <= 32'h317900d6;
      8: out3 <= 32'h2d413ccd;
      9: out3 <= 32'h2899e64a;
      10: out3 <= 32'h238e7673;
      11: out3 <= 32'h1e2b5d38;
      12: out3 <= 32'h187de2a7;
      13: out3 <= 32'h1294062f;
      14: out3 <= 32'hc7c5c1e;
      15: out3 <= 32'h645e9af;
      16: out3 <= 32'h0;
      17: out3 <= 32'hf9ba1651;
      18: out3 <= 32'hf383a3e2;
      19: out3 <= 32'hed6bf9d1;
      20: out3 <= 32'he7821d59;
      21: out3 <= 32'he1d4a2c8;
      22: out3 <= 32'hdc71898d;
      23: out3 <= 32'hd76619b6;
      24: out3 <= 32'hd2bec333;
      25: out3 <= 32'hce86ff2a;
      26: out3 <= 32'hcac933ae;
      27: out3 <= 32'hc78e9a1d;
      28: out3 <= 32'hc4df2862;
      29: out3 <= 32'hc2c17d52;
      30: out3 <= 32'hc13ad060;
      31: out3 <= 32'hc04ee4b8;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "block"
endmodule



// Latency: 12
// Gap: 1
module codeBlock52920(clk, reset, next_in, next_out,
   i5_in,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3);

   output next_out;
   input clk, reset, next_in;

   reg next;
   input [4:0] i5_in;
   reg [4:0] i5;

   input [31:0] X0_in,
      X1_in,
      X2_in,
      X3_in;

   reg   [31:0] X0,
      X1,
      X2,
      X3;

   output [31:0] Y0,
      Y1,
      Y2,
      Y3;

   shiftRegFIFO #(11, 1) shiftFIFO_60072(.X(next), .Y(next_out), .clk(clk));


   wire signed [31:0] a293;
   wire signed [31:0] a282;
   wire signed [31:0] a296;
   wire signed [31:0] a286;
   wire signed [31:0] a297;
   wire signed [31:0] a298;
   reg signed [31:0] tm386;
   reg signed [31:0] tm390;
   reg signed [31:0] tm402;
   reg signed [31:0] tm413;
   reg signed [31:0] tm387;
   reg signed [31:0] tm391;
   reg signed [31:0] tm403;
   reg signed [31:0] tm414;
   wire signed [31:0] tm18;
   wire signed [31:0] a287;
   wire signed [31:0] tm19;
   wire signed [31:0] a289;
   reg signed [31:0] tm388;
   reg signed [31:0] tm392;
   reg signed [31:0] tm404;
   reg signed [31:0] tm415;
   reg signed [31:0] tm72;
   reg signed [31:0] tm73;
   reg signed [31:0] tm389;
   reg signed [31:0] tm393;
   reg signed [31:0] tm405;
   reg signed [31:0] tm416;
   reg signed [31:0] tm406;
   reg signed [31:0] tm417;
   reg signed [31:0] tm407;
   reg signed [31:0] tm418;
   reg signed [31:0] tm408;
   reg signed [31:0] tm419;
   reg signed [31:0] tm409;
   reg signed [31:0] tm420;
   reg signed [31:0] tm410;
   reg signed [31:0] tm421;
   wire signed [31:0] a288;
   wire signed [31:0] a290;
   wire signed [31:0] a291;
   wire signed [31:0] a292;
   reg signed [31:0] tm411;
   reg signed [31:0] tm422;
   wire signed [31:0] Y0;
   wire signed [31:0] Y1;
   wire signed [31:0] Y2;
   wire signed [31:0] Y3;
   reg signed [31:0] tm412;
   reg signed [31:0] tm423;


   assign a293 = X0;
   assign a282 = a293;
   assign a296 = X1;
   assign a286 = a296;
   assign a297 = X2;
   assign a298 = X3;
   assign a287 = tm18;
   assign a289 = tm19;
   assign Y0 = tm412;
   assign Y1 = tm423;

   D20_53114 instD20inst0_53114(.addr(i5[4:0]), .out(tm19), .clk(clk));

   D18_53182 instD18inst0_53182(.addr(i5[4:0]), .out(tm18), .clk(clk));

    multfix #(32, 6) m53019(.a(tm72), .b(tm389), .clk(clk), .q_sc(a288), .q_unsc(), .rst(reset));
    multfix #(32, 6) m53041(.a(tm73), .b(tm393), .clk(clk), .q_sc(a290), .q_unsc(), .rst(reset));
    multfix #(32, 6) m53059(.a(tm73), .b(tm389), .clk(clk), .q_sc(a291), .q_unsc(), .rst(reset));
    multfix #(32, 6) m53070(.a(tm72), .b(tm393), .clk(clk), .q_sc(a292), .q_unsc(), .rst(reset));
    subfxp #(32, 1) sub53048(.a(a288), .b(a290), .clk(clk), .q(Y2));    // 10
    addfxp #(32, 1) add53077(.a(a291), .b(a292), .clk(clk), .q(Y3));    // 10


   always @(posedge clk) begin
      if (reset == 1) begin
         tm72 <= 0;
         tm389 <= 0;
         tm73 <= 0;
         tm393 <= 0;
         tm73 <= 0;
         tm389 <= 0;
         tm72 <= 0;
         tm393 <= 0;
      end
      else begin
         i5 <= i5_in;
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         next <= next_in;
         tm386 <= a297;
         tm390 <= a298;
         tm402 <= a282;
         tm413 <= a286;
         tm387 <= tm386;
         tm391 <= tm390;
         tm403 <= tm402;
         tm414 <= tm413;
         tm388 <= tm387;
         tm392 <= tm391;
         tm404 <= tm403;
         tm415 <= tm414;
         tm72 <= a287;
         tm73 <= a289;
         tm389 <= tm388;
         tm393 <= tm392;
         tm405 <= tm404;
         tm416 <= tm415;
         tm406 <= tm405;
         tm417 <= tm416;
         tm407 <= tm406;
         tm418 <= tm417;
         tm408 <= tm407;
         tm419 <= tm418;
         tm409 <= tm408;
         tm420 <= tm419;
         tm410 <= tm409;
         tm421 <= tm420;
         tm411 <= tm410;
         tm422 <= tm421;
         tm412 <= tm411;
         tm423 <= tm422;
      end
   end
endmodule

// Latency: 2
// Gap: 1
module codeBlock53221(clk, reset, next_in, next_out,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3);

   output next_out;
   input clk, reset, next_in;

   reg next;

   input [31:0] X0_in,
      X1_in,
      X2_in,
      X3_in;

   reg   [31:0] X0,
      X1,
      X2,
      X3;

   output [31:0] Y0,
      Y1,
      Y2,
      Y3;

   shiftRegFIFO #(1, 1) shiftFIFO_60075(.X(next), .Y(next_out), .clk(clk));


   wire signed [31:0] a249;
   wire signed [31:0] a250;
   wire signed [31:0] a251;
   wire signed [31:0] a252;
   wire signed [31:0] t117;
   wire signed [31:0] t118;
   wire signed [31:0] t119;
   wire signed [31:0] t120;
   wire signed [31:0] Y0;
   wire signed [31:0] Y1;
   wire signed [31:0] Y2;
   wire signed [31:0] Y3;


   assign a249 = X0;
   assign a250 = X2;
   assign a251 = X1;
   assign a252 = X3;
   assign Y0 = t117;
   assign Y1 = t118;
   assign Y2 = t119;
   assign Y3 = t120;

    addfxp #(32, 1) add53233(.a(a249), .b(a250), .clk(clk), .q(t117));    // 0
    addfxp #(32, 1) add53248(.a(a251), .b(a252), .clk(clk), .q(t118));    // 0
    subfxp #(32, 1) sub53263(.a(a249), .b(a250), .clk(clk), .q(t119));    // 0
    subfxp #(32, 1) sub53278(.a(a251), .b(a252), .clk(clk), .q(t120));    // 0


   always @(posedge clk) begin
      if (reset == 1) begin
      end
      else begin
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         next <= next_in;
      end
   end
endmodule

// Latency: 35
// Gap: 64
module rc53302(clk, reset, next, next_out,
   X0, Y0,
   X1, Y1,
   X2, Y2,
   X3, Y3);

   output next_out;
   input clk, reset, next;

   input [31:0] X0,
      X1,
      X2,
      X3;

   output [31:0] Y0,
      Y1,
      Y2,
      Y3;

   wire [63:0] t0;
   wire [63:0] s0;
   assign t0 = {X0, X1};
   wire [63:0] t1;
   wire [63:0] s1;
   assign t1 = {X2, X3};
   assign Y0 = s0[63:32];
   assign Y1 = s0[31:0];
   assign Y2 = s1[63:32];
   assign Y3 = s1[31:0];

   perm53300 instPerm60076(.x0(t0), .y0(s0),
    .x1(t1), .y1(s1),
   .clk(clk), .next(next), .next_out(next_out), .reset(reset)
);



endmodule

// Latency: 35
// Gap: 64
module perm53300(clk, next, reset, next_out,
   x0, y0,
   x1, y1);
   parameter numBanks = 2;
   parameter logBanks = 1;
   parameter depth = 64;
   parameter logDepth = 6;
   parameter width = 64;

   input [width-1:0]  x0;
   output [width-1:0]  y0;
   wire [width-1:0]  ybuff0;
   input [width-1:0]  x1;
   output [width-1:0]  y1;
   wire [width-1:0]  ybuff1;
   input 	      clk, next, reset;
   output 	     next_out;

   wire    	     next0;

   reg              inFlip0, outFlip0;
   reg              inActive, outActive;

   wire [logBanks-1:0] inBank0, outBank0;
   wire [logDepth-1:0] inAddr0, outAddr0;
   wire [logBanks-1:0] outBank_a0;
   wire [logDepth-1:0] outAddr_a0;
   wire [logDepth+logBanks-1:0] addr0, addr0b, addr0c;
   wire [logBanks-1:0] inBank1, outBank1;
   wire [logDepth-1:0] inAddr1, outAddr1;
   wire [logBanks-1:0] outBank_a1;
   wire [logDepth-1:0] outAddr_a1;
   wire [logDepth+logBanks-1:0] addr1, addr1b, addr1c;


   reg [logDepth-1:0]  inCount, outCount, outCount_d, outCount_dd, outCount_for_rd_addr, outCount_for_rd_data;  

   assign    addr0 = {inCount, 1'd0};
   assign    addr0b = {outCount, 1'd0};
   assign    addr0c = {outCount_for_rd_addr, 1'd0};
   assign    addr1 = {inCount, 1'd1};
   assign    addr1b = {outCount, 1'd1};
   assign    addr1c = {outCount_for_rd_addr, 1'd1};
    wire [width+logDepth-1:0] w_0_0, w_0_1, w_1_0, w_1_1;

    reg [width-1:0] z_0_0;
    reg [width-1:0] z_0_1;
    wire [width-1:0] z_1_0, z_1_1;

    wire [logDepth-1:0] u_0_0, u_0_1, u_1_0, u_1_1;

    always @(posedge clk) begin
    end

   assign inBank0[0] = addr0[6] ^ addr0[0];
   assign inAddr0[0] = addr0[1];
   assign inAddr0[1] = addr0[2];
   assign inAddr0[2] = addr0[3];
   assign inAddr0[3] = addr0[4];
   assign inAddr0[4] = addr0[5];
   assign inAddr0[5] = addr0[0];
   assign outBank0[0] = addr0b[6] ^ addr0b[0];
   assign outAddr0[0] = addr0b[1];
   assign outAddr0[1] = addr0b[2];
   assign outAddr0[2] = addr0b[3];
   assign outAddr0[3] = addr0b[4];
   assign outAddr0[4] = addr0b[5];
   assign outAddr0[5] = addr0b[6];
   assign outBank_a0[0] = addr0c[6] ^ addr0c[0];
   assign outAddr_a0[0] = addr0c[1];
   assign outAddr_a0[1] = addr0c[2];
   assign outAddr_a0[2] = addr0c[3];
   assign outAddr_a0[3] = addr0c[4];
   assign outAddr_a0[4] = addr0c[5];
   assign outAddr_a0[5] = addr0c[6];

   assign inBank1[0] = addr1[6] ^ addr1[0];
   assign inAddr1[0] = addr1[1];
   assign inAddr1[1] = addr1[2];
   assign inAddr1[2] = addr1[3];
   assign inAddr1[3] = addr1[4];
   assign inAddr1[4] = addr1[5];
   assign inAddr1[5] = addr1[0];
   assign outBank1[0] = addr1b[6] ^ addr1b[0];
   assign outAddr1[0] = addr1b[1];
   assign outAddr1[1] = addr1b[2];
   assign outAddr1[2] = addr1b[3];
   assign outAddr1[3] = addr1b[4];
   assign outAddr1[4] = addr1b[5];
   assign outAddr1[5] = addr1b[6];
   assign outBank_a1[0] = addr1c[6] ^ addr1c[0];
   assign outAddr_a1[0] = addr1c[1];
   assign outAddr_a1[1] = addr1c[2];
   assign outAddr_a1[2] = addr1c[3];
   assign outAddr_a1[3] = addr1c[4];
   assign outAddr_a1[4] = addr1c[5];
   assign outAddr_a1[5] = addr1c[6];

   nextReg #(33, 6) nextReg_60081(.X(next), .Y(next0), .reset(reset), .clk(clk));


   shiftRegFIFO #(2, 1) shiftFIFO_60084(.X(next0), .Y(next_out), .clk(clk));


   memArray128_53300 #(numBanks, logBanks, depth, logDepth, width)
     memSys(.inFlip(inFlip0), .outFlip(outFlip0), .next(next), .reset(reset),
        .x0(w_1_0[width+logDepth-1:logDepth]), .y0(ybuff0),
        .inAddr0(w_1_0[logDepth-1:0]),
        .outAddr0(u_1_0), 
        .x1(w_1_1[width+logDepth-1:logDepth]), .y1(ybuff1),
        .inAddr1(w_1_1[logDepth-1:0]),
        .outAddr1(u_1_1), 
        .clk(clk));

   always @(posedge clk) begin
      if (reset == 1) begin
      z_0_0 <= 0;
      z_0_1 <= 0;
         inFlip0 <= 0; outFlip0 <= 1; outCount <= 0; inCount <= 0;
        outCount_for_rd_addr <= 0;
        outCount_for_rd_data <= 0;
      end
      else begin
          outCount_d <= outCount;
          outCount_dd <= outCount_d;
         if (inCount == 32)
            outCount_for_rd_addr <= 0;
         else
            outCount_for_rd_addr <= outCount_for_rd_addr+1;
         if (inCount == 34)
            outCount_for_rd_data <= 0;
         else
            outCount_for_rd_data <= outCount_for_rd_data+1;
      z_0_0 <= ybuff0;
      z_0_1 <= ybuff1;
         if (inCount == 32) begin
            outFlip0 <= ~outFlip0;
            outCount <= 0;
         end
         else
            outCount <= outCount+1;
         if (inCount == 63) begin
            inFlip0 <= ~inFlip0;
         end
         if (next == 1) begin
            if (inCount >= 32)
               inFlip0 <= ~inFlip0;
            inCount <= 0;
         end
         else
            inCount <= inCount + 1;
      end
   end
    assign w_0_0 = {x0, inAddr0};
    assign w_0_1 = {x1, inAddr1};
    assign y0 = z_1_0;
    assign y1 = z_1_1;
    assign u_0_0 = outAddr_a0;
    assign u_0_1 = outAddr_a1;
    wire wr_ctrl_st_0;
    assign wr_ctrl_st_0 = inCount[5];

    switch #(logDepth+width) in_sw_0_0(.x0(w_0_0), .x1(w_0_1), .y0(w_1_0), .y1(w_1_1), .ctrl(wr_ctrl_st_0));
    wire rdd_ctrl_st_0;
    assign rdd_ctrl_st_0 = outCount_for_rd_data[5];

    switch #(width) out_sw_0_0(.x0(z_0_0), .x1(z_0_1), .y0(z_1_0), .y1(z_1_1), .ctrl(rdd_ctrl_st_0));
    wire rda_ctrl_st_0;
    assign rda_ctrl_st_0 = outCount_for_rd_addr[5];

    switch #(logDepth) rdaddr_sw_0_0(.x0(u_0_0), .x1(u_0_1), .y0(u_1_0), .y1(u_1_1), .ctrl(rda_ctrl_st_0));
endmodule

module memArray128_53300(next, reset,
                x0, y0,
                inAddr0,
                outAddr0,
                x1, y1,
                inAddr1,
                outAddr1,
                clk, inFlip, outFlip);

   parameter numBanks = 2;
   parameter logBanks = 1;
   parameter depth = 64;
   parameter logDepth = 6;
   parameter width = 64;
         
   input     clk, next, reset;
   input    inFlip, outFlip;
   wire    next0;
   
   input [width-1:0]   x0;
   output [width-1:0]  y0;
   input [logDepth-1:0] inAddr0, outAddr0;
   input [width-1:0]   x1;
   output [width-1:0]  y1;
   input [logDepth-1:0] inAddr1, outAddr1;
   nextReg #(64, 6) nextReg_60089(.X(next), .Y(next0), .reset(reset), .clk(clk));


   memMod #(depth*2, width, logDepth+1) 
     memMod0(.in(x0), .out(y0), .inAddr({inFlip, inAddr0}),
	   .outAddr({outFlip, outAddr0}), .writeSel(1'b1), .clk(clk));   
   memMod #(depth*2, width, logDepth+1) 
     memMod1(.in(x1), .out(y1), .inAddr({inFlip, inAddr1}),
	   .outAddr({outFlip, outAddr1}), .writeSel(1'b1), .clk(clk));   
endmodule

// Latency: 12
// Gap: 64
module DirSum_53731(clk, reset, next, next_out,
      X0, Y0,
      X1, Y1,
      X2, Y2,
      X3, Y3);

   output next_out;
   input clk, reset, next;

   reg [5:0] i4;

   input [31:0] X0,
      X1,
      X2,
      X3;

   output [31:0] Y0,
      Y1,
      Y2,
      Y3;

   always @(posedge clk) begin
      if (reset == 1) begin
         i4 <= 0;
      end
      else begin
         if (next == 1)
            i4 <= 0;
         else if (i4 == 63)
            i4 <= 0;
         else
            i4 <= i4 + 1;
      end
   end

   codeBlock53305 codeBlockIsnt60094(.clk(clk), .reset(reset), .next_in(next), .next_out(next_out),
.i4_in(i4),
       .X0_in(X0), .Y0(Y0),
       .X1_in(X1), .Y1(Y1),
       .X2_in(X2), .Y2(Y2),
       .X3_in(X3), .Y3(Y3));

endmodule

module D16_53531(addr, out, clk);
   input clk;
   output [31:0] out;
   reg [31:0] out, out2, out3;
   input [5:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 32'h0;
      1: out3 <= 32'hfcdc1342;
      2: out3 <= 32'hf9ba1651;
      3: out3 <= 32'hf69bf7c9;
      4: out3 <= 32'hf383a3e2;
      5: out3 <= 32'hf0730342;
      6: out3 <= 32'hed6bf9d1;
      7: out3 <= 32'hea70658a;
      8: out3 <= 32'he7821d59;
      9: out3 <= 32'he4a2eff6;
      10: out3 <= 32'he1d4a2c8;
      11: out3 <= 32'hdf18f0ce;
      12: out3 <= 32'hdc71898d;
      13: out3 <= 32'hd9e01006;
      14: out3 <= 32'hd76619b6;
      15: out3 <= 32'hd5052d97;
      16: out3 <= 32'hd2bec333;
      17: out3 <= 32'hd09441bb;
      18: out3 <= 32'hce86ff2a;
      19: out3 <= 32'hcc983f70;
      20: out3 <= 32'hcac933ae;
      21: out3 <= 32'hc91af976;
      22: out3 <= 32'hc78e9a1d;
      23: out3 <= 32'hc6250a18;
      24: out3 <= 32'hc4df2862;
      25: out3 <= 32'hc3bdbdf6;
      26: out3 <= 32'hc2c17d52;
      27: out3 <= 32'hc1eb0209;
      28: out3 <= 32'hc13ad060;
      29: out3 <= 32'hc0b15502;
      30: out3 <= 32'hc04ee4b8;
      31: out3 <= 32'hc013bc39;
      32: out3 <= 32'hc0000000;
      33: out3 <= 32'hc013bc39;
      34: out3 <= 32'hc04ee4b8;
      35: out3 <= 32'hc0b15502;
      36: out3 <= 32'hc13ad060;
      37: out3 <= 32'hc1eb0209;
      38: out3 <= 32'hc2c17d52;
      39: out3 <= 32'hc3bdbdf6;
      40: out3 <= 32'hc4df2862;
      41: out3 <= 32'hc6250a18;
      42: out3 <= 32'hc78e9a1d;
      43: out3 <= 32'hc91af976;
      44: out3 <= 32'hcac933ae;
      45: out3 <= 32'hcc983f70;
      46: out3 <= 32'hce86ff2a;
      47: out3 <= 32'hd09441bb;
      48: out3 <= 32'hd2bec333;
      49: out3 <= 32'hd5052d97;
      50: out3 <= 32'hd76619b6;
      51: out3 <= 32'hd9e01006;
      52: out3 <= 32'hdc71898d;
      53: out3 <= 32'hdf18f0ce;
      54: out3 <= 32'he1d4a2c8;
      55: out3 <= 32'he4a2eff6;
      56: out3 <= 32'he7821d59;
      57: out3 <= 32'hea70658a;
      58: out3 <= 32'hed6bf9d1;
      59: out3 <= 32'hf0730342;
      60: out3 <= 32'hf383a3e2;
      61: out3 <= 32'hf69bf7c9;
      62: out3 <= 32'hf9ba1651;
      63: out3 <= 32'hfcdc1342;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "block"
endmodule



module D14_53729(addr, out, clk);
   input clk;
   output [31:0] out;
   reg [31:0] out, out2, out3;
   input [5:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 32'h40000000;
      1: out3 <= 32'h3fec43c7;
      2: out3 <= 32'h3fb11b48;
      3: out3 <= 32'h3f4eaafe;
      4: out3 <= 32'h3ec52fa0;
      5: out3 <= 32'h3e14fdf7;
      6: out3 <= 32'h3d3e82ae;
      7: out3 <= 32'h3c42420a;
      8: out3 <= 32'h3b20d79e;
      9: out3 <= 32'h39daf5e8;
      10: out3 <= 32'h387165e3;
      11: out3 <= 32'h36e5068a;
      12: out3 <= 32'h3536cc52;
      13: out3 <= 32'h3367c090;
      14: out3 <= 32'h317900d6;
      15: out3 <= 32'h2f6bbe45;
      16: out3 <= 32'h2d413ccd;
      17: out3 <= 32'h2afad269;
      18: out3 <= 32'h2899e64a;
      19: out3 <= 32'h261feffa;
      20: out3 <= 32'h238e7673;
      21: out3 <= 32'h20e70f32;
      22: out3 <= 32'h1e2b5d38;
      23: out3 <= 32'h1b5d100a;
      24: out3 <= 32'h187de2a7;
      25: out3 <= 32'h158f9a76;
      26: out3 <= 32'h1294062f;
      27: out3 <= 32'hf8cfcbe;
      28: out3 <= 32'hc7c5c1e;
      29: out3 <= 32'h9640837;
      30: out3 <= 32'h645e9af;
      31: out3 <= 32'h323ecbe;
      32: out3 <= 32'h0;
      33: out3 <= 32'hfcdc1342;
      34: out3 <= 32'hf9ba1651;
      35: out3 <= 32'hf69bf7c9;
      36: out3 <= 32'hf383a3e2;
      37: out3 <= 32'hf0730342;
      38: out3 <= 32'hed6bf9d1;
      39: out3 <= 32'hea70658a;
      40: out3 <= 32'he7821d59;
      41: out3 <= 32'he4a2eff6;
      42: out3 <= 32'he1d4a2c8;
      43: out3 <= 32'hdf18f0ce;
      44: out3 <= 32'hdc71898d;
      45: out3 <= 32'hd9e01006;
      46: out3 <= 32'hd76619b6;
      47: out3 <= 32'hd5052d97;
      48: out3 <= 32'hd2bec333;
      49: out3 <= 32'hd09441bb;
      50: out3 <= 32'hce86ff2a;
      51: out3 <= 32'hcc983f70;
      52: out3 <= 32'hcac933ae;
      53: out3 <= 32'hc91af976;
      54: out3 <= 32'hc78e9a1d;
      55: out3 <= 32'hc6250a18;
      56: out3 <= 32'hc4df2862;
      57: out3 <= 32'hc3bdbdf6;
      58: out3 <= 32'hc2c17d52;
      59: out3 <= 32'hc1eb0209;
      60: out3 <= 32'hc13ad060;
      61: out3 <= 32'hc0b15502;
      62: out3 <= 32'hc04ee4b8;
      63: out3 <= 32'hc013bc39;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "block"
endmodule



// Latency: 12
// Gap: 1
module codeBlock53305(clk, reset, next_in, next_out,
   i4_in,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3);

   output next_out;
   input clk, reset, next_in;

   reg next;
   input [5:0] i4_in;
   reg [5:0] i4;

   input [31:0] X0_in,
      X1_in,
      X2_in,
      X3_in;

   reg   [31:0] X0,
      X1,
      X2,
      X3;

   output [31:0] Y0,
      Y1,
      Y2,
      Y3;

   shiftRegFIFO #(11, 1) shiftFIFO_60097(.X(next), .Y(next_out), .clk(clk));


   wire signed [31:0] a233;
   wire signed [31:0] a222;
   wire signed [31:0] a236;
   wire signed [31:0] a226;
   wire signed [31:0] a237;
   wire signed [31:0] a238;
   reg signed [31:0] tm424;
   reg signed [31:0] tm428;
   reg signed [31:0] tm440;
   reg signed [31:0] tm451;
   reg signed [31:0] tm425;
   reg signed [31:0] tm429;
   reg signed [31:0] tm441;
   reg signed [31:0] tm452;
   wire signed [31:0] tm22;
   wire signed [31:0] a227;
   wire signed [31:0] tm23;
   wire signed [31:0] a229;
   reg signed [31:0] tm426;
   reg signed [31:0] tm430;
   reg signed [31:0] tm442;
   reg signed [31:0] tm453;
   reg signed [31:0] tm80;
   reg signed [31:0] tm81;
   reg signed [31:0] tm427;
   reg signed [31:0] tm431;
   reg signed [31:0] tm443;
   reg signed [31:0] tm454;
   reg signed [31:0] tm444;
   reg signed [31:0] tm455;
   reg signed [31:0] tm445;
   reg signed [31:0] tm456;
   reg signed [31:0] tm446;
   reg signed [31:0] tm457;
   reg signed [31:0] tm447;
   reg signed [31:0] tm458;
   reg signed [31:0] tm448;
   reg signed [31:0] tm459;
   wire signed [31:0] a228;
   wire signed [31:0] a230;
   wire signed [31:0] a231;
   wire signed [31:0] a232;
   reg signed [31:0] tm449;
   reg signed [31:0] tm460;
   wire signed [31:0] Y0;
   wire signed [31:0] Y1;
   wire signed [31:0] Y2;
   wire signed [31:0] Y3;
   reg signed [31:0] tm450;
   reg signed [31:0] tm461;


   assign a233 = X0;
   assign a222 = a233;
   assign a236 = X1;
   assign a226 = a236;
   assign a237 = X2;
   assign a238 = X3;
   assign a227 = tm22;
   assign a229 = tm23;
   assign Y0 = tm450;
   assign Y1 = tm461;

   D16_53531 instD16inst0_53531(.addr(i4[5:0]), .out(tm23), .clk(clk));

   D14_53729 instD14inst0_53729(.addr(i4[5:0]), .out(tm22), .clk(clk));

    multfix #(32, 6) m53404(.a(tm80), .b(tm427), .clk(clk), .q_sc(a228), .q_unsc(), .rst(reset));
    multfix #(32, 6) m53426(.a(tm81), .b(tm431), .clk(clk), .q_sc(a230), .q_unsc(), .rst(reset));
    multfix #(32, 6) m53444(.a(tm81), .b(tm427), .clk(clk), .q_sc(a231), .q_unsc(), .rst(reset));
    multfix #(32, 6) m53455(.a(tm80), .b(tm431), .clk(clk), .q_sc(a232), .q_unsc(), .rst(reset));
    subfxp #(32, 1) sub53433(.a(a228), .b(a230), .clk(clk), .q(Y2));    // 10
    addfxp #(32, 1) add53462(.a(a231), .b(a232), .clk(clk), .q(Y3));    // 10


   always @(posedge clk) begin
      if (reset == 1) begin
         tm80 <= 0;
         tm427 <= 0;
         tm81 <= 0;
         tm431 <= 0;
         tm81 <= 0;
         tm427 <= 0;
         tm80 <= 0;
         tm431 <= 0;
      end
      else begin
         i4 <= i4_in;
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         next <= next_in;
         tm424 <= a237;
         tm428 <= a238;
         tm440 <= a222;
         tm451 <= a226;
         tm425 <= tm424;
         tm429 <= tm428;
         tm441 <= tm440;
         tm452 <= tm451;
         tm426 <= tm425;
         tm430 <= tm429;
         tm442 <= tm441;
         tm453 <= tm452;
         tm80 <= a227;
         tm81 <= a229;
         tm427 <= tm426;
         tm431 <= tm430;
         tm443 <= tm442;
         tm454 <= tm453;
         tm444 <= tm443;
         tm455 <= tm454;
         tm445 <= tm444;
         tm456 <= tm455;
         tm446 <= tm445;
         tm457 <= tm456;
         tm447 <= tm446;
         tm458 <= tm457;
         tm448 <= tm447;
         tm459 <= tm458;
         tm449 <= tm448;
         tm460 <= tm459;
         tm450 <= tm449;
         tm461 <= tm460;
      end
   end
endmodule

// Latency: 2
// Gap: 1
module codeBlock53734(clk, reset, next_in, next_out,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3);

   output next_out;
   input clk, reset, next_in;

   reg next;

   input [31:0] X0_in,
      X1_in,
      X2_in,
      X3_in;

   reg   [31:0] X0,
      X1,
      X2,
      X3;

   output [31:0] Y0,
      Y1,
      Y2,
      Y3;

   shiftRegFIFO #(1, 1) shiftFIFO_60100(.X(next), .Y(next_out), .clk(clk));


   wire signed [31:0] a189;
   wire signed [31:0] a190;
   wire signed [31:0] a191;
   wire signed [31:0] a192;
   wire signed [31:0] t93;
   wire signed [31:0] t94;
   wire signed [31:0] t95;
   wire signed [31:0] t96;
   wire signed [31:0] Y0;
   wire signed [31:0] Y1;
   wire signed [31:0] Y2;
   wire signed [31:0] Y3;


   assign a189 = X0;
   assign a190 = X2;
   assign a191 = X1;
   assign a192 = X3;
   assign Y0 = t93;
   assign Y1 = t94;
   assign Y2 = t95;
   assign Y3 = t96;

    addfxp #(32, 1) add53746(.a(a189), .b(a190), .clk(clk), .q(t93));    // 0
    addfxp #(32, 1) add53761(.a(a191), .b(a192), .clk(clk), .q(t94));    // 0
    subfxp #(32, 1) sub53776(.a(a189), .b(a190), .clk(clk), .q(t95));    // 0
    subfxp #(32, 1) sub53791(.a(a191), .b(a192), .clk(clk), .q(t96));    // 0


   always @(posedge clk) begin
      if (reset == 1) begin
      end
      else begin
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         next <= next_in;
      end
   end
endmodule

// Latency: 67
// Gap: 128
module rc53815(clk, reset, next, next_out,
   X0, Y0,
   X1, Y1,
   X2, Y2,
   X3, Y3);

   output next_out;
   input clk, reset, next;

   input [31:0] X0,
      X1,
      X2,
      X3;

   output [31:0] Y0,
      Y1,
      Y2,
      Y3;

   wire [63:0] t0;
   wire [63:0] s0;
   assign t0 = {X0, X1};
   wire [63:0] t1;
   wire [63:0] s1;
   assign t1 = {X2, X3};
   assign Y0 = s0[63:32];
   assign Y1 = s0[31:0];
   assign Y2 = s1[63:32];
   assign Y3 = s1[31:0];

   perm53813 instPerm60101(.x0(t0), .y0(s0),
    .x1(t1), .y1(s1),
   .clk(clk), .next(next), .next_out(next_out), .reset(reset)
);



endmodule

// Latency: 67
// Gap: 128
module perm53813(clk, next, reset, next_out,
   x0, y0,
   x1, y1);
   parameter numBanks = 2;
   parameter logBanks = 1;
   parameter depth = 128;
   parameter logDepth = 7;
   parameter width = 64;

   input [width-1:0]  x0;
   output [width-1:0]  y0;
   wire [width-1:0]  ybuff0;
   input [width-1:0]  x1;
   output [width-1:0]  y1;
   wire [width-1:0]  ybuff1;
   input 	      clk, next, reset;
   output 	     next_out;

   wire    	     next0;

   reg              inFlip0, outFlip0;
   reg              inActive, outActive;

   wire [logBanks-1:0] inBank0, outBank0;
   wire [logDepth-1:0] inAddr0, outAddr0;
   wire [logBanks-1:0] outBank_a0;
   wire [logDepth-1:0] outAddr_a0;
   wire [logDepth+logBanks-1:0] addr0, addr0b, addr0c;
   wire [logBanks-1:0] inBank1, outBank1;
   wire [logDepth-1:0] inAddr1, outAddr1;
   wire [logBanks-1:0] outBank_a1;
   wire [logDepth-1:0] outAddr_a1;
   wire [logDepth+logBanks-1:0] addr1, addr1b, addr1c;


   reg [logDepth-1:0]  inCount, outCount, outCount_d, outCount_dd, outCount_for_rd_addr, outCount_for_rd_data;  

   assign    addr0 = {inCount, 1'd0};
   assign    addr0b = {outCount, 1'd0};
   assign    addr0c = {outCount_for_rd_addr, 1'd0};
   assign    addr1 = {inCount, 1'd1};
   assign    addr1b = {outCount, 1'd1};
   assign    addr1c = {outCount_for_rd_addr, 1'd1};
    wire [width+logDepth-1:0] w_0_0, w_0_1, w_1_0, w_1_1;

    reg [width-1:0] z_0_0;
    reg [width-1:0] z_0_1;
    wire [width-1:0] z_1_0, z_1_1;

    wire [logDepth-1:0] u_0_0, u_0_1, u_1_0, u_1_1;

    always @(posedge clk) begin
    end

   assign inBank0[0] = addr0[7] ^ addr0[0];
   assign inAddr0[0] = addr0[1];
   assign inAddr0[1] = addr0[2];
   assign inAddr0[2] = addr0[3];
   assign inAddr0[3] = addr0[4];
   assign inAddr0[4] = addr0[5];
   assign inAddr0[5] = addr0[6];
   assign inAddr0[6] = addr0[0];
   assign outBank0[0] = addr0b[7] ^ addr0b[0];
   assign outAddr0[0] = addr0b[1];
   assign outAddr0[1] = addr0b[2];
   assign outAddr0[2] = addr0b[3];
   assign outAddr0[3] = addr0b[4];
   assign outAddr0[4] = addr0b[5];
   assign outAddr0[5] = addr0b[6];
   assign outAddr0[6] = addr0b[7];
   assign outBank_a0[0] = addr0c[7] ^ addr0c[0];
   assign outAddr_a0[0] = addr0c[1];
   assign outAddr_a0[1] = addr0c[2];
   assign outAddr_a0[2] = addr0c[3];
   assign outAddr_a0[3] = addr0c[4];
   assign outAddr_a0[4] = addr0c[5];
   assign outAddr_a0[5] = addr0c[6];
   assign outAddr_a0[6] = addr0c[7];

   assign inBank1[0] = addr1[7] ^ addr1[0];
   assign inAddr1[0] = addr1[1];
   assign inAddr1[1] = addr1[2];
   assign inAddr1[2] = addr1[3];
   assign inAddr1[3] = addr1[4];
   assign inAddr1[4] = addr1[5];
   assign inAddr1[5] = addr1[6];
   assign inAddr1[6] = addr1[0];
   assign outBank1[0] = addr1b[7] ^ addr1b[0];
   assign outAddr1[0] = addr1b[1];
   assign outAddr1[1] = addr1b[2];
   assign outAddr1[2] = addr1b[3];
   assign outAddr1[3] = addr1b[4];
   assign outAddr1[4] = addr1b[5];
   assign outAddr1[5] = addr1b[6];
   assign outAddr1[6] = addr1b[7];
   assign outBank_a1[0] = addr1c[7] ^ addr1c[0];
   assign outAddr_a1[0] = addr1c[1];
   assign outAddr_a1[1] = addr1c[2];
   assign outAddr_a1[2] = addr1c[3];
   assign outAddr_a1[3] = addr1c[4];
   assign outAddr_a1[4] = addr1c[5];
   assign outAddr_a1[5] = addr1c[6];
   assign outAddr_a1[6] = addr1c[7];

   nextReg #(65, 7) nextReg_60106(.X(next), .Y(next0), .reset(reset), .clk(clk));


   shiftRegFIFO #(2, 1) shiftFIFO_60109(.X(next0), .Y(next_out), .clk(clk));


   memArray256_53813 #(numBanks, logBanks, depth, logDepth, width)
     memSys(.inFlip(inFlip0), .outFlip(outFlip0), .next(next), .reset(reset),
        .x0(w_1_0[width+logDepth-1:logDepth]), .y0(ybuff0),
        .inAddr0(w_1_0[logDepth-1:0]),
        .outAddr0(u_1_0), 
        .x1(w_1_1[width+logDepth-1:logDepth]), .y1(ybuff1),
        .inAddr1(w_1_1[logDepth-1:0]),
        .outAddr1(u_1_1), 
        .clk(clk));

   always @(posedge clk) begin
      if (reset == 1) begin
      z_0_0 <= 0;
      z_0_1 <= 0;
         inFlip0 <= 0; outFlip0 <= 1; outCount <= 0; inCount <= 0;
        outCount_for_rd_addr <= 0;
        outCount_for_rd_data <= 0;
      end
      else begin
          outCount_d <= outCount;
          outCount_dd <= outCount_d;
         if (inCount == 64)
            outCount_for_rd_addr <= 0;
         else
            outCount_for_rd_addr <= outCount_for_rd_addr+1;
         if (inCount == 66)
            outCount_for_rd_data <= 0;
         else
            outCount_for_rd_data <= outCount_for_rd_data+1;
      z_0_0 <= ybuff0;
      z_0_1 <= ybuff1;
         if (inCount == 64) begin
            outFlip0 <= ~outFlip0;
            outCount <= 0;
         end
         else
            outCount <= outCount+1;
         if (inCount == 127) begin
            inFlip0 <= ~inFlip0;
         end
         if (next == 1) begin
            if (inCount >= 64)
               inFlip0 <= ~inFlip0;
            inCount <= 0;
         end
         else
            inCount <= inCount + 1;
      end
   end
    assign w_0_0 = {x0, inAddr0};
    assign w_0_1 = {x1, inAddr1};
    assign y0 = z_1_0;
    assign y1 = z_1_1;
    assign u_0_0 = outAddr_a0;
    assign u_0_1 = outAddr_a1;
    wire wr_ctrl_st_0;
    assign wr_ctrl_st_0 = inCount[6];

    switch #(logDepth+width) in_sw_0_0(.x0(w_0_0), .x1(w_0_1), .y0(w_1_0), .y1(w_1_1), .ctrl(wr_ctrl_st_0));
    wire rdd_ctrl_st_0;
    assign rdd_ctrl_st_0 = outCount_for_rd_data[6];

    switch #(width) out_sw_0_0(.x0(z_0_0), .x1(z_0_1), .y0(z_1_0), .y1(z_1_1), .ctrl(rdd_ctrl_st_0));
    wire rda_ctrl_st_0;
    assign rda_ctrl_st_0 = outCount_for_rd_addr[6];

    switch #(logDepth) rdaddr_sw_0_0(.x0(u_0_0), .x1(u_0_1), .y0(u_1_0), .y1(u_1_1), .ctrl(rda_ctrl_st_0));
endmodule

module memArray256_53813(next, reset,
                x0, y0,
                inAddr0,
                outAddr0,
                x1, y1,
                inAddr1,
                outAddr1,
                clk, inFlip, outFlip);

   parameter numBanks = 2;
   parameter logBanks = 1;
   parameter depth = 128;
   parameter logDepth = 7;
   parameter width = 64;
         
   input     clk, next, reset;
   input    inFlip, outFlip;
   wire    next0;
   
   input [width-1:0]   x0;
   output [width-1:0]  y0;
   input [logDepth-1:0] inAddr0, outAddr0;
   input [width-1:0]   x1;
   output [width-1:0]  y1;
   input [logDepth-1:0] inAddr1, outAddr1;
   nextReg #(128, 7) nextReg_60114(.X(next), .Y(next0), .reset(reset), .clk(clk));


   memMod #(depth*2, width, logDepth+1) 
     memMod0(.in(x0), .out(y0), .inAddr({inFlip, inAddr0}),
	   .outAddr({outFlip, outAddr0}), .writeSel(1'b1), .clk(clk));   
   memMod #(depth*2, width, logDepth+1) 
     memMod1(.in(x1), .out(y1), .inAddr({inFlip, inAddr1}),
	   .outAddr({outFlip, outAddr1}), .writeSel(1'b1), .clk(clk));   
endmodule

// Latency: 12
// Gap: 128
module DirSum_54500(clk, reset, next, next_out,
      X0, Y0,
      X1, Y1,
      X2, Y2,
      X3, Y3);

   output next_out;
   input clk, reset, next;

   reg [6:0] i3;

   input [31:0] X0,
      X1,
      X2,
      X3;

   output [31:0] Y0,
      Y1,
      Y2,
      Y3;

   always @(posedge clk) begin
      if (reset == 1) begin
         i3 <= 0;
      end
      else begin
         if (next == 1)
            i3 <= 0;
         else if (i3 == 127)
            i3 <= 0;
         else
            i3 <= i3 + 1;
      end
   end

   codeBlock53818 codeBlockIsnt60119(.clk(clk), .reset(reset), .next_in(next), .next_out(next_out),
.i3_in(i3),
       .X0_in(X0), .Y0(Y0),
       .X1_in(X1), .Y1(Y1),
       .X2_in(X2), .Y2(Y2),
       .X3_in(X3), .Y3(Y3));

endmodule

module D10_54238(addr, out, clk);
   input clk;
   output [31:0] out;
   reg [31:0] out, out2, out3;
   input [6:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 32'h40000000;
      1: out3 <= 32'h3ffb10c1;
      2: out3 <= 32'h3fec43c7;
      3: out3 <= 32'h3fd39b5a;
      4: out3 <= 32'h3fb11b48;
      5: out3 <= 32'h3f84c8e2;
      6: out3 <= 32'h3f4eaafe;
      7: out3 <= 32'h3f0ec9f5;
      8: out3 <= 32'h3ec52fa0;
      9: out3 <= 32'h3e71e759;
      10: out3 <= 32'h3e14fdf7;
      11: out3 <= 32'h3dae81cf;
      12: out3 <= 32'h3d3e82ae;
      13: out3 <= 32'h3cc511d9;
      14: out3 <= 32'h3c42420a;
      15: out3 <= 32'h3bb6276e;
      16: out3 <= 32'h3b20d79e;
      17: out3 <= 32'h3a8269a3;
      18: out3 <= 32'h39daf5e8;
      19: out3 <= 32'h392a9642;
      20: out3 <= 32'h387165e3;
      21: out3 <= 32'h37af8159;
      22: out3 <= 32'h36e5068a;
      23: out3 <= 32'h361214b0;
      24: out3 <= 32'h3536cc52;
      25: out3 <= 32'h34534f41;
      26: out3 <= 32'h3367c090;
      27: out3 <= 32'h32744493;
      28: out3 <= 32'h317900d6;
      29: out3 <= 32'h30761c18;
      30: out3 <= 32'h2f6bbe45;
      31: out3 <= 32'h2e5a1070;
      32: out3 <= 32'h2d413ccd;
      33: out3 <= 32'h2c216eaa;
      34: out3 <= 32'h2afad269;
      35: out3 <= 32'h29cd9578;
      36: out3 <= 32'h2899e64a;
      37: out3 <= 32'h275ff452;
      38: out3 <= 32'h261feffa;
      39: out3 <= 32'h24da0a9a;
      40: out3 <= 32'h238e7673;
      41: out3 <= 32'h223d66a8;
      42: out3 <= 32'h20e70f32;
      43: out3 <= 32'h1f8ba4dc;
      44: out3 <= 32'h1e2b5d38;
      45: out3 <= 32'h1cc66e99;
      46: out3 <= 32'h1b5d100a;
      47: out3 <= 32'h19ef7944;
      48: out3 <= 32'h187de2a7;
      49: out3 <= 32'h17088531;
      50: out3 <= 32'h158f9a76;
      51: out3 <= 32'h14135c94;
      52: out3 <= 32'h1294062f;
      53: out3 <= 32'h1111d263;
      54: out3 <= 32'hf8cfcbe;
      55: out3 <= 32'he05c135;
      56: out3 <= 32'hc7c5c1e;
      57: out3 <= 32'haf10a22;
      58: out3 <= 32'h9640837;
      59: out3 <= 32'h7d59396;
      60: out3 <= 32'h645e9af;
      61: out3 <= 32'h4b54825;
      62: out3 <= 32'h323ecbe;
      63: out3 <= 32'h192155f;
      64: out3 <= 32'h0;
      65: out3 <= 32'hfe6deaa1;
      66: out3 <= 32'hfcdc1342;
      67: out3 <= 32'hfb4ab7db;
      68: out3 <= 32'hf9ba1651;
      69: out3 <= 32'hf82a6c6a;
      70: out3 <= 32'hf69bf7c9;
      71: out3 <= 32'hf50ef5de;
      72: out3 <= 32'hf383a3e2;
      73: out3 <= 32'hf1fa3ecb;
      74: out3 <= 32'hf0730342;
      75: out3 <= 32'heeee2d9d;
      76: out3 <= 32'hed6bf9d1;
      77: out3 <= 32'hebeca36c;
      78: out3 <= 32'hea70658a;
      79: out3 <= 32'he8f77acf;
      80: out3 <= 32'he7821d59;
      81: out3 <= 32'he61086bc;
      82: out3 <= 32'he4a2eff6;
      83: out3 <= 32'he3399167;
      84: out3 <= 32'he1d4a2c8;
      85: out3 <= 32'he0745b24;
      86: out3 <= 32'hdf18f0ce;
      87: out3 <= 32'hddc29958;
      88: out3 <= 32'hdc71898d;
      89: out3 <= 32'hdb25f566;
      90: out3 <= 32'hd9e01006;
      91: out3 <= 32'hd8a00bae;
      92: out3 <= 32'hd76619b6;
      93: out3 <= 32'hd6326a88;
      94: out3 <= 32'hd5052d97;
      95: out3 <= 32'hd3de9156;
      96: out3 <= 32'hd2bec333;
      97: out3 <= 32'hd1a5ef90;
      98: out3 <= 32'hd09441bb;
      99: out3 <= 32'hcf89e3e8;
      100: out3 <= 32'hce86ff2a;
      101: out3 <= 32'hcd8bbb6d;
      102: out3 <= 32'hcc983f70;
      103: out3 <= 32'hcbacb0bf;
      104: out3 <= 32'hcac933ae;
      105: out3 <= 32'hc9edeb50;
      106: out3 <= 32'hc91af976;
      107: out3 <= 32'hc8507ea7;
      108: out3 <= 32'hc78e9a1d;
      109: out3 <= 32'hc6d569be;
      110: out3 <= 32'hc6250a18;
      111: out3 <= 32'hc57d965d;
      112: out3 <= 32'hc4df2862;
      113: out3 <= 32'hc449d892;
      114: out3 <= 32'hc3bdbdf6;
      115: out3 <= 32'hc33aee27;
      116: out3 <= 32'hc2c17d52;
      117: out3 <= 32'hc2517e31;
      118: out3 <= 32'hc1eb0209;
      119: out3 <= 32'hc18e18a7;
      120: out3 <= 32'hc13ad060;
      121: out3 <= 32'hc0f1360b;
      122: out3 <= 32'hc0b15502;
      123: out3 <= 32'hc07b371e;
      124: out3 <= 32'hc04ee4b8;
      125: out3 <= 32'hc02c64a6;
      126: out3 <= 32'hc013bc39;
      127: out3 <= 32'hc004ef3f;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "block"
endmodule



module D12_54498(addr, out, clk);
   input clk;
   output [31:0] out;
   reg [31:0] out, out2, out3;
   input [6:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 32'h0;
      1: out3 <= 32'hfe6deaa1;
      2: out3 <= 32'hfcdc1342;
      3: out3 <= 32'hfb4ab7db;
      4: out3 <= 32'hf9ba1651;
      5: out3 <= 32'hf82a6c6a;
      6: out3 <= 32'hf69bf7c9;
      7: out3 <= 32'hf50ef5de;
      8: out3 <= 32'hf383a3e2;
      9: out3 <= 32'hf1fa3ecb;
      10: out3 <= 32'hf0730342;
      11: out3 <= 32'heeee2d9d;
      12: out3 <= 32'hed6bf9d1;
      13: out3 <= 32'hebeca36c;
      14: out3 <= 32'hea70658a;
      15: out3 <= 32'he8f77acf;
      16: out3 <= 32'he7821d59;
      17: out3 <= 32'he61086bc;
      18: out3 <= 32'he4a2eff6;
      19: out3 <= 32'he3399167;
      20: out3 <= 32'he1d4a2c8;
      21: out3 <= 32'he0745b24;
      22: out3 <= 32'hdf18f0ce;
      23: out3 <= 32'hddc29958;
      24: out3 <= 32'hdc71898d;
      25: out3 <= 32'hdb25f566;
      26: out3 <= 32'hd9e01006;
      27: out3 <= 32'hd8a00bae;
      28: out3 <= 32'hd76619b6;
      29: out3 <= 32'hd6326a88;
      30: out3 <= 32'hd5052d97;
      31: out3 <= 32'hd3de9156;
      32: out3 <= 32'hd2bec333;
      33: out3 <= 32'hd1a5ef90;
      34: out3 <= 32'hd09441bb;
      35: out3 <= 32'hcf89e3e8;
      36: out3 <= 32'hce86ff2a;
      37: out3 <= 32'hcd8bbb6d;
      38: out3 <= 32'hcc983f70;
      39: out3 <= 32'hcbacb0bf;
      40: out3 <= 32'hcac933ae;
      41: out3 <= 32'hc9edeb50;
      42: out3 <= 32'hc91af976;
      43: out3 <= 32'hc8507ea7;
      44: out3 <= 32'hc78e9a1d;
      45: out3 <= 32'hc6d569be;
      46: out3 <= 32'hc6250a18;
      47: out3 <= 32'hc57d965d;
      48: out3 <= 32'hc4df2862;
      49: out3 <= 32'hc449d892;
      50: out3 <= 32'hc3bdbdf6;
      51: out3 <= 32'hc33aee27;
      52: out3 <= 32'hc2c17d52;
      53: out3 <= 32'hc2517e31;
      54: out3 <= 32'hc1eb0209;
      55: out3 <= 32'hc18e18a7;
      56: out3 <= 32'hc13ad060;
      57: out3 <= 32'hc0f1360b;
      58: out3 <= 32'hc0b15502;
      59: out3 <= 32'hc07b371e;
      60: out3 <= 32'hc04ee4b8;
      61: out3 <= 32'hc02c64a6;
      62: out3 <= 32'hc013bc39;
      63: out3 <= 32'hc004ef3f;
      64: out3 <= 32'hc0000000;
      65: out3 <= 32'hc004ef3f;
      66: out3 <= 32'hc013bc39;
      67: out3 <= 32'hc02c64a6;
      68: out3 <= 32'hc04ee4b8;
      69: out3 <= 32'hc07b371e;
      70: out3 <= 32'hc0b15502;
      71: out3 <= 32'hc0f1360b;
      72: out3 <= 32'hc13ad060;
      73: out3 <= 32'hc18e18a7;
      74: out3 <= 32'hc1eb0209;
      75: out3 <= 32'hc2517e31;
      76: out3 <= 32'hc2c17d52;
      77: out3 <= 32'hc33aee27;
      78: out3 <= 32'hc3bdbdf6;
      79: out3 <= 32'hc449d892;
      80: out3 <= 32'hc4df2862;
      81: out3 <= 32'hc57d965d;
      82: out3 <= 32'hc6250a18;
      83: out3 <= 32'hc6d569be;
      84: out3 <= 32'hc78e9a1d;
      85: out3 <= 32'hc8507ea7;
      86: out3 <= 32'hc91af976;
      87: out3 <= 32'hc9edeb50;
      88: out3 <= 32'hcac933ae;
      89: out3 <= 32'hcbacb0bf;
      90: out3 <= 32'hcc983f70;
      91: out3 <= 32'hcd8bbb6d;
      92: out3 <= 32'hce86ff2a;
      93: out3 <= 32'hcf89e3e8;
      94: out3 <= 32'hd09441bb;
      95: out3 <= 32'hd1a5ef90;
      96: out3 <= 32'hd2bec333;
      97: out3 <= 32'hd3de9156;
      98: out3 <= 32'hd5052d97;
      99: out3 <= 32'hd6326a88;
      100: out3 <= 32'hd76619b6;
      101: out3 <= 32'hd8a00bae;
      102: out3 <= 32'hd9e01006;
      103: out3 <= 32'hdb25f566;
      104: out3 <= 32'hdc71898d;
      105: out3 <= 32'hddc29958;
      106: out3 <= 32'hdf18f0ce;
      107: out3 <= 32'he0745b24;
      108: out3 <= 32'he1d4a2c8;
      109: out3 <= 32'he3399167;
      110: out3 <= 32'he4a2eff6;
      111: out3 <= 32'he61086bc;
      112: out3 <= 32'he7821d59;
      113: out3 <= 32'he8f77acf;
      114: out3 <= 32'hea70658a;
      115: out3 <= 32'hebeca36c;
      116: out3 <= 32'hed6bf9d1;
      117: out3 <= 32'heeee2d9d;
      118: out3 <= 32'hf0730342;
      119: out3 <= 32'hf1fa3ecb;
      120: out3 <= 32'hf383a3e2;
      121: out3 <= 32'hf50ef5de;
      122: out3 <= 32'hf69bf7c9;
      123: out3 <= 32'hf82a6c6a;
      124: out3 <= 32'hf9ba1651;
      125: out3 <= 32'hfb4ab7db;
      126: out3 <= 32'hfcdc1342;
      127: out3 <= 32'hfe6deaa1;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "block"
endmodule



// Latency: 12
// Gap: 1
module codeBlock53818(clk, reset, next_in, next_out,
   i3_in,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3);

   output next_out;
   input clk, reset, next_in;

   reg next;
   input [6:0] i3_in;
   reg [6:0] i3;

   input [31:0] X0_in,
      X1_in,
      X2_in,
      X3_in;

   reg   [31:0] X0,
      X1,
      X2,
      X3;

   output [31:0] Y0,
      Y1,
      Y2,
      Y3;

   shiftRegFIFO #(11, 1) shiftFIFO_60122(.X(next), .Y(next_out), .clk(clk));


   wire signed [31:0] a173;
   wire signed [31:0] a162;
   wire signed [31:0] a176;
   wire signed [31:0] a166;
   wire signed [31:0] a177;
   wire signed [31:0] a178;
   reg signed [31:0] tm462;
   reg signed [31:0] tm466;
   reg signed [31:0] tm478;
   reg signed [31:0] tm489;
   reg signed [31:0] tm463;
   reg signed [31:0] tm467;
   reg signed [31:0] tm479;
   reg signed [31:0] tm490;
   wire signed [31:0] tm26;
   wire signed [31:0] a167;
   wire signed [31:0] tm27;
   wire signed [31:0] a169;
   reg signed [31:0] tm464;
   reg signed [31:0] tm468;
   reg signed [31:0] tm480;
   reg signed [31:0] tm491;
   reg signed [31:0] tm88;
   reg signed [31:0] tm89;
   reg signed [31:0] tm465;
   reg signed [31:0] tm469;
   reg signed [31:0] tm481;
   reg signed [31:0] tm492;
   reg signed [31:0] tm482;
   reg signed [31:0] tm493;
   reg signed [31:0] tm483;
   reg signed [31:0] tm494;
   reg signed [31:0] tm484;
   reg signed [31:0] tm495;
   reg signed [31:0] tm485;
   reg signed [31:0] tm496;
   reg signed [31:0] tm486;
   reg signed [31:0] tm497;
   wire signed [31:0] a168;
   wire signed [31:0] a170;
   wire signed [31:0] a171;
   wire signed [31:0] a172;
   reg signed [31:0] tm487;
   reg signed [31:0] tm498;
   wire signed [31:0] Y0;
   wire signed [31:0] Y1;
   wire signed [31:0] Y2;
   wire signed [31:0] Y3;
   reg signed [31:0] tm488;
   reg signed [31:0] tm499;


   assign a173 = X0;
   assign a162 = a173;
   assign a176 = X1;
   assign a166 = a176;
   assign a177 = X2;
   assign a178 = X3;
   assign a167 = tm26;
   assign a169 = tm27;
   assign Y0 = tm488;
   assign Y1 = tm499;

   D10_54238 instD10inst0_54238(.addr(i3[6:0]), .out(tm26), .clk(clk));

   D12_54498 instD12inst0_54498(.addr(i3[6:0]), .out(tm27), .clk(clk));

    multfix #(32, 6) m53917(.a(tm88), .b(tm465), .clk(clk), .q_sc(a168), .q_unsc(), .rst(reset));
    multfix #(32, 6) m53939(.a(tm89), .b(tm469), .clk(clk), .q_sc(a170), .q_unsc(), .rst(reset));
    multfix #(32, 6) m53957(.a(tm89), .b(tm465), .clk(clk), .q_sc(a171), .q_unsc(), .rst(reset));
    multfix #(32, 6) m53968(.a(tm88), .b(tm469), .clk(clk), .q_sc(a172), .q_unsc(), .rst(reset));
    subfxp #(32, 1) sub53946(.a(a168), .b(a170), .clk(clk), .q(Y2));    // 10
    addfxp #(32, 1) add53975(.a(a171), .b(a172), .clk(clk), .q(Y3));    // 10


   always @(posedge clk) begin
      if (reset == 1) begin
         tm88 <= 0;
         tm465 <= 0;
         tm89 <= 0;
         tm469 <= 0;
         tm89 <= 0;
         tm465 <= 0;
         tm88 <= 0;
         tm469 <= 0;
      end
      else begin
         i3 <= i3_in;
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         next <= next_in;
         tm462 <= a177;
         tm466 <= a178;
         tm478 <= a162;
         tm489 <= a166;
         tm463 <= tm462;
         tm467 <= tm466;
         tm479 <= tm478;
         tm490 <= tm489;
         tm464 <= tm463;
         tm468 <= tm467;
         tm480 <= tm479;
         tm491 <= tm490;
         tm88 <= a167;
         tm89 <= a169;
         tm465 <= tm464;
         tm469 <= tm468;
         tm481 <= tm480;
         tm492 <= tm491;
         tm482 <= tm481;
         tm493 <= tm492;
         tm483 <= tm482;
         tm494 <= tm493;
         tm484 <= tm483;
         tm495 <= tm494;
         tm485 <= tm484;
         tm496 <= tm495;
         tm486 <= tm485;
         tm497 <= tm496;
         tm487 <= tm486;
         tm498 <= tm497;
         tm488 <= tm487;
         tm499 <= tm498;
      end
   end
endmodule

// Latency: 2
// Gap: 1
module codeBlock54503(clk, reset, next_in, next_out,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3);

   output next_out;
   input clk, reset, next_in;

   reg next;

   input [31:0] X0_in,
      X1_in,
      X2_in,
      X3_in;

   reg   [31:0] X0,
      X1,
      X2,
      X3;

   output [31:0] Y0,
      Y1,
      Y2,
      Y3;

   shiftRegFIFO #(1, 1) shiftFIFO_60125(.X(next), .Y(next_out), .clk(clk));


   wire signed [31:0] a129;
   wire signed [31:0] a130;
   wire signed [31:0] a131;
   wire signed [31:0] a132;
   wire signed [31:0] t69;
   wire signed [31:0] t70;
   wire signed [31:0] t71;
   wire signed [31:0] t72;
   wire signed [31:0] Y0;
   wire signed [31:0] Y1;
   wire signed [31:0] Y2;
   wire signed [31:0] Y3;


   assign a129 = X0;
   assign a130 = X2;
   assign a131 = X1;
   assign a132 = X3;
   assign Y0 = t69;
   assign Y1 = t70;
   assign Y2 = t71;
   assign Y3 = t72;

    addfxp #(32, 1) add54515(.a(a129), .b(a130), .clk(clk), .q(t69));    // 0
    addfxp #(32, 1) add54530(.a(a131), .b(a132), .clk(clk), .q(t70));    // 0
    subfxp #(32, 1) sub54545(.a(a129), .b(a130), .clk(clk), .q(t71));    // 0
    subfxp #(32, 1) sub54560(.a(a131), .b(a132), .clk(clk), .q(t72));    // 0


   always @(posedge clk) begin
      if (reset == 1) begin
      end
      else begin
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         next <= next_in;
      end
   end
endmodule

// Latency: 131
// Gap: 256
module rc54584(clk, reset, next, next_out,
   X0, Y0,
   X1, Y1,
   X2, Y2,
   X3, Y3);

   output next_out;
   input clk, reset, next;

   input [31:0] X0,
      X1,
      X2,
      X3;

   output [31:0] Y0,
      Y1,
      Y2,
      Y3;

   wire [63:0] t0;
   wire [63:0] s0;
   assign t0 = {X0, X1};
   wire [63:0] t1;
   wire [63:0] s1;
   assign t1 = {X2, X3};
   assign Y0 = s0[63:32];
   assign Y1 = s0[31:0];
   assign Y2 = s1[63:32];
   assign Y3 = s1[31:0];

   perm54582 instPerm60126(.x0(t0), .y0(s0),
    .x1(t1), .y1(s1),
   .clk(clk), .next(next), .next_out(next_out), .reset(reset)
);



endmodule

// Latency: 131
// Gap: 256
module perm54582(clk, next, reset, next_out,
   x0, y0,
   x1, y1);
   parameter numBanks = 2;
   parameter logBanks = 1;
   parameter depth = 256;
   parameter logDepth = 8;
   parameter width = 64;

   input [width-1:0]  x0;
   output [width-1:0]  y0;
   wire [width-1:0]  ybuff0;
   input [width-1:0]  x1;
   output [width-1:0]  y1;
   wire [width-1:0]  ybuff1;
   input 	      clk, next, reset;
   output 	     next_out;

   wire    	     next0;

   reg              inFlip0, outFlip0;
   reg              inActive, outActive;

   wire [logBanks-1:0] inBank0, outBank0;
   wire [logDepth-1:0] inAddr0, outAddr0;
   wire [logBanks-1:0] outBank_a0;
   wire [logDepth-1:0] outAddr_a0;
   wire [logDepth+logBanks-1:0] addr0, addr0b, addr0c;
   wire [logBanks-1:0] inBank1, outBank1;
   wire [logDepth-1:0] inAddr1, outAddr1;
   wire [logBanks-1:0] outBank_a1;
   wire [logDepth-1:0] outAddr_a1;
   wire [logDepth+logBanks-1:0] addr1, addr1b, addr1c;


   reg [logDepth-1:0]  inCount, outCount, outCount_d, outCount_dd, outCount_for_rd_addr, outCount_for_rd_data;  

   assign    addr0 = {inCount, 1'd0};
   assign    addr0b = {outCount, 1'd0};
   assign    addr0c = {outCount_for_rd_addr, 1'd0};
   assign    addr1 = {inCount, 1'd1};
   assign    addr1b = {outCount, 1'd1};
   assign    addr1c = {outCount_for_rd_addr, 1'd1};
    wire [width+logDepth-1:0] w_0_0, w_0_1, w_1_0, w_1_1;

    reg [width-1:0] z_0_0;
    reg [width-1:0] z_0_1;
    wire [width-1:0] z_1_0, z_1_1;

    wire [logDepth-1:0] u_0_0, u_0_1, u_1_0, u_1_1;

    always @(posedge clk) begin
    end

   assign inBank0[0] = addr0[8] ^ addr0[0];
   assign inAddr0[0] = addr0[1];
   assign inAddr0[1] = addr0[2];
   assign inAddr0[2] = addr0[3];
   assign inAddr0[3] = addr0[4];
   assign inAddr0[4] = addr0[5];
   assign inAddr0[5] = addr0[6];
   assign inAddr0[6] = addr0[7];
   assign inAddr0[7] = addr0[0];
   assign outBank0[0] = addr0b[8] ^ addr0b[0];
   assign outAddr0[0] = addr0b[1];
   assign outAddr0[1] = addr0b[2];
   assign outAddr0[2] = addr0b[3];
   assign outAddr0[3] = addr0b[4];
   assign outAddr0[4] = addr0b[5];
   assign outAddr0[5] = addr0b[6];
   assign outAddr0[6] = addr0b[7];
   assign outAddr0[7] = addr0b[8];
   assign outBank_a0[0] = addr0c[8] ^ addr0c[0];
   assign outAddr_a0[0] = addr0c[1];
   assign outAddr_a0[1] = addr0c[2];
   assign outAddr_a0[2] = addr0c[3];
   assign outAddr_a0[3] = addr0c[4];
   assign outAddr_a0[4] = addr0c[5];
   assign outAddr_a0[5] = addr0c[6];
   assign outAddr_a0[6] = addr0c[7];
   assign outAddr_a0[7] = addr0c[8];

   assign inBank1[0] = addr1[8] ^ addr1[0];
   assign inAddr1[0] = addr1[1];
   assign inAddr1[1] = addr1[2];
   assign inAddr1[2] = addr1[3];
   assign inAddr1[3] = addr1[4];
   assign inAddr1[4] = addr1[5];
   assign inAddr1[5] = addr1[6];
   assign inAddr1[6] = addr1[7];
   assign inAddr1[7] = addr1[0];
   assign outBank1[0] = addr1b[8] ^ addr1b[0];
   assign outAddr1[0] = addr1b[1];
   assign outAddr1[1] = addr1b[2];
   assign outAddr1[2] = addr1b[3];
   assign outAddr1[3] = addr1b[4];
   assign outAddr1[4] = addr1b[5];
   assign outAddr1[5] = addr1b[6];
   assign outAddr1[6] = addr1b[7];
   assign outAddr1[7] = addr1b[8];
   assign outBank_a1[0] = addr1c[8] ^ addr1c[0];
   assign outAddr_a1[0] = addr1c[1];
   assign outAddr_a1[1] = addr1c[2];
   assign outAddr_a1[2] = addr1c[3];
   assign outAddr_a1[3] = addr1c[4];
   assign outAddr_a1[4] = addr1c[5];
   assign outAddr_a1[5] = addr1c[6];
   assign outAddr_a1[6] = addr1c[7];
   assign outAddr_a1[7] = addr1c[8];

   nextReg #(129, 8) nextReg_60131(.X(next), .Y(next0), .reset(reset), .clk(clk));


   shiftRegFIFO #(2, 1) shiftFIFO_60134(.X(next0), .Y(next_out), .clk(clk));


   memArray512_54582 #(numBanks, logBanks, depth, logDepth, width)
     memSys(.inFlip(inFlip0), .outFlip(outFlip0), .next(next), .reset(reset),
        .x0(w_1_0[width+logDepth-1:logDepth]), .y0(ybuff0),
        .inAddr0(w_1_0[logDepth-1:0]),
        .outAddr0(u_1_0), 
        .x1(w_1_1[width+logDepth-1:logDepth]), .y1(ybuff1),
        .inAddr1(w_1_1[logDepth-1:0]),
        .outAddr1(u_1_1), 
        .clk(clk));

   always @(posedge clk) begin
      if (reset == 1) begin
      z_0_0 <= 0;
      z_0_1 <= 0;
         inFlip0 <= 0; outFlip0 <= 1; outCount <= 0; inCount <= 0;
        outCount_for_rd_addr <= 0;
        outCount_for_rd_data <= 0;
      end
      else begin
          outCount_d <= outCount;
          outCount_dd <= outCount_d;
         if (inCount == 128)
            outCount_for_rd_addr <= 0;
         else
            outCount_for_rd_addr <= outCount_for_rd_addr+1;
         if (inCount == 130)
            outCount_for_rd_data <= 0;
         else
            outCount_for_rd_data <= outCount_for_rd_data+1;
      z_0_0 <= ybuff0;
      z_0_1 <= ybuff1;
         if (inCount == 128) begin
            outFlip0 <= ~outFlip0;
            outCount <= 0;
         end
         else
            outCount <= outCount+1;
         if (inCount == 255) begin
            inFlip0 <= ~inFlip0;
         end
         if (next == 1) begin
            if (inCount >= 128)
               inFlip0 <= ~inFlip0;
            inCount <= 0;
         end
         else
            inCount <= inCount + 1;
      end
   end
    assign w_0_0 = {x0, inAddr0};
    assign w_0_1 = {x1, inAddr1};
    assign y0 = z_1_0;
    assign y1 = z_1_1;
    assign u_0_0 = outAddr_a0;
    assign u_0_1 = outAddr_a1;
    wire wr_ctrl_st_0;
    assign wr_ctrl_st_0 = inCount[7];

    switch #(logDepth+width) in_sw_0_0(.x0(w_0_0), .x1(w_0_1), .y0(w_1_0), .y1(w_1_1), .ctrl(wr_ctrl_st_0));
    wire rdd_ctrl_st_0;
    assign rdd_ctrl_st_0 = outCount_for_rd_data[7];

    switch #(width) out_sw_0_0(.x0(z_0_0), .x1(z_0_1), .y0(z_1_0), .y1(z_1_1), .ctrl(rdd_ctrl_st_0));
    wire rda_ctrl_st_0;
    assign rda_ctrl_st_0 = outCount_for_rd_addr[7];

    switch #(logDepth) rdaddr_sw_0_0(.x0(u_0_0), .x1(u_0_1), .y0(u_1_0), .y1(u_1_1), .ctrl(rda_ctrl_st_0));
endmodule

module memArray512_54582(next, reset,
                x0, y0,
                inAddr0,
                outAddr0,
                x1, y1,
                inAddr1,
                outAddr1,
                clk, inFlip, outFlip);

   parameter numBanks = 2;
   parameter logBanks = 1;
   parameter depth = 256;
   parameter logDepth = 8;
   parameter width = 64;
         
   input     clk, next, reset;
   input    inFlip, outFlip;
   wire    next0;
   
   input [width-1:0]   x0;
   output [width-1:0]  y0;
   input [logDepth-1:0] inAddr0, outAddr0;
   input [width-1:0]   x1;
   output [width-1:0]  y1;
   input [logDepth-1:0] inAddr1, outAddr1;
   nextReg #(256, 8) nextReg_60139(.X(next), .Y(next0), .reset(reset), .clk(clk));


   memMod #(depth*2, width, logDepth+1) 
     memMod0(.in(x0), .out(y0), .inAddr({inFlip, inAddr0}),
	   .outAddr({outFlip, outAddr0}), .writeSel(1'b1), .clk(clk));   
   memMod #(depth*2, width, logDepth+1) 
     memMod1(.in(x1), .out(y1), .inAddr({inFlip, inAddr1}),
	   .outAddr({outFlip, outAddr1}), .writeSel(1'b1), .clk(clk));   
endmodule

// Latency: 12
// Gap: 256
module DirSum_55781(clk, reset, next, next_out,
      X0, Y0,
      X1, Y1,
      X2, Y2,
      X3, Y3);

   output next_out;
   input clk, reset, next;

   reg [7:0] i2;

   input [31:0] X0,
      X1,
      X2,
      X3;

   output [31:0] Y0,
      Y1,
      Y2,
      Y3;

   always @(posedge clk) begin
      if (reset == 1) begin
         i2 <= 0;
      end
      else begin
         if (next == 1)
            i2 <= 0;
         else if (i2 == 255)
            i2 <= 0;
         else
            i2 <= i2 + 1;
      end
   end

   codeBlock54587 codeBlockIsnt60144(.clk(clk), .reset(reset), .next_in(next), .next_out(next_out),
.i2_in(i2),
       .X0_in(X0), .Y0(Y0),
       .X1_in(X1), .Y1(Y1),
       .X2_in(X2), .Y2(Y2),
       .X3_in(X3), .Y3(Y3));

endmodule

module D8_55005(addr, out, clk);
   input clk;
   output [31:0] out;
   reg [31:0] out, out2, out3;
   input [7:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 32'h0;
      1: out3 <= 32'hff36f170;
      2: out3 <= 32'hfe6deaa1;
      3: out3 <= 32'hfda4f351;
      4: out3 <= 32'hfcdc1342;
      5: out3 <= 32'hfc135231;
      6: out3 <= 32'hfb4ab7db;
      7: out3 <= 32'hfa824bfd;
      8: out3 <= 32'hf9ba1651;
      9: out3 <= 32'hf8f21e8e;
      10: out3 <= 32'hf82a6c6a;
      11: out3 <= 32'hf7630799;
      12: out3 <= 32'hf69bf7c9;
      13: out3 <= 32'hf5d544a7;
      14: out3 <= 32'hf50ef5de;
      15: out3 <= 32'hf4491311;
      16: out3 <= 32'hf383a3e2;
      17: out3 <= 32'hf2beafed;
      18: out3 <= 32'hf1fa3ecb;
      19: out3 <= 32'hf136580d;
      20: out3 <= 32'hf0730342;
      21: out3 <= 32'hefb047f2;
      22: out3 <= 32'heeee2d9d;
      23: out3 <= 32'hee2cbbc1;
      24: out3 <= 32'hed6bf9d1;
      25: out3 <= 32'hecabef3d;
      26: out3 <= 32'hebeca36c;
      27: out3 <= 32'heb2e1dbe;
      28: out3 <= 32'hea70658a;
      29: out3 <= 32'he9b38223;
      30: out3 <= 32'he8f77acf;
      31: out3 <= 32'he83c56cf;
      32: out3 <= 32'he7821d59;
      33: out3 <= 32'he6c8d59c;
      34: out3 <= 32'he61086bc;
      35: out3 <= 32'he55937d5;
      36: out3 <= 32'he4a2eff6;
      37: out3 <= 32'he3edb628;
      38: out3 <= 32'he3399167;
      39: out3 <= 32'he28688a4;
      40: out3 <= 32'he1d4a2c8;
      41: out3 <= 32'he123e6ad;
      42: out3 <= 32'he0745b24;
      43: out3 <= 32'hdfc606f1;
      44: out3 <= 32'hdf18f0ce;
      45: out3 <= 32'hde6d1f65;
      46: out3 <= 32'hddc29958;
      47: out3 <= 32'hdd196538;
      48: out3 <= 32'hdc71898d;
      49: out3 <= 32'hdbcb0cce;
      50: out3 <= 32'hdb25f566;
      51: out3 <= 32'hda8249b4;
      52: out3 <= 32'hd9e01006;
      53: out3 <= 32'hd93f4e9e;
      54: out3 <= 32'hd8a00bae;
      55: out3 <= 32'hd8024d59;
      56: out3 <= 32'hd76619b6;
      57: out3 <= 32'hd6cb76c9;
      58: out3 <= 32'hd6326a88;
      59: out3 <= 32'hd59afadb;
      60: out3 <= 32'hd5052d97;
      61: out3 <= 32'hd4710883;
      62: out3 <= 32'hd3de9156;
      63: out3 <= 32'hd34dcdb4;
      64: out3 <= 32'hd2bec333;
      65: out3 <= 32'hd2317756;
      66: out3 <= 32'hd1a5ef90;
      67: out3 <= 32'hd11c3142;
      68: out3 <= 32'hd09441bb;
      69: out3 <= 32'hd00e2639;
      70: out3 <= 32'hcf89e3e8;
      71: out3 <= 32'hcf077fe1;
      72: out3 <= 32'hce86ff2a;
      73: out3 <= 32'hce0866b8;
      74: out3 <= 32'hcd8bbb6d;
      75: out3 <= 32'hcd110216;
      76: out3 <= 32'hcc983f70;
      77: out3 <= 32'hcc217822;
      78: out3 <= 32'hcbacb0bf;
      79: out3 <= 32'hcb39edca;
      80: out3 <= 32'hcac933ae;
      81: out3 <= 32'hca5a86c4;
      82: out3 <= 32'hc9edeb50;
      83: out3 <= 32'hc9836582;
      84: out3 <= 32'hc91af976;
      85: out3 <= 32'hc8b4ab32;
      86: out3 <= 32'hc8507ea7;
      87: out3 <= 32'hc7ee77b3;
      88: out3 <= 32'hc78e9a1d;
      89: out3 <= 32'hc730e997;
      90: out3 <= 32'hc6d569be;
      91: out3 <= 32'hc67c1e18;
      92: out3 <= 32'hc6250a18;
      93: out3 <= 32'hc5d03118;
      94: out3 <= 32'hc57d965d;
      95: out3 <= 32'hc52d3d18;
      96: out3 <= 32'hc4df2862;
      97: out3 <= 32'hc4935b3c;
      98: out3 <= 32'hc449d892;
      99: out3 <= 32'hc402a33c;
      100: out3 <= 32'hc3bdbdf6;
      101: out3 <= 32'hc37b2b6a;
      102: out3 <= 32'hc33aee27;
      103: out3 <= 32'hc2fd08a9;
      104: out3 <= 32'hc2c17d52;
      105: out3 <= 32'hc2884e6e;
      106: out3 <= 32'hc2517e31;
      107: out3 <= 32'hc21d0eb8;
      108: out3 <= 32'hc1eb0209;
      109: out3 <= 32'hc1bb5a11;
      110: out3 <= 32'hc18e18a7;
      111: out3 <= 32'hc1633f8a;
      112: out3 <= 32'hc13ad060;
      113: out3 <= 32'hc114ccb9;
      114: out3 <= 32'hc0f1360b;
      115: out3 <= 32'hc0d00db6;
      116: out3 <= 32'hc0b15502;
      117: out3 <= 32'hc0950d1d;
      118: out3 <= 32'hc07b371e;
      119: out3 <= 32'hc063d405;
      120: out3 <= 32'hc04ee4b8;
      121: out3 <= 32'hc03c6a07;
      122: out3 <= 32'hc02c64a6;
      123: out3 <= 32'hc01ed535;
      124: out3 <= 32'hc013bc39;
      125: out3 <= 32'hc00b1a20;
      126: out3 <= 32'hc004ef3f;
      127: out3 <= 32'hc0013bd3;
      128: out3 <= 32'hc0000000;
      129: out3 <= 32'hc0013bd3;
      130: out3 <= 32'hc004ef3f;
      131: out3 <= 32'hc00b1a20;
      132: out3 <= 32'hc013bc39;
      133: out3 <= 32'hc01ed535;
      134: out3 <= 32'hc02c64a6;
      135: out3 <= 32'hc03c6a07;
      136: out3 <= 32'hc04ee4b8;
      137: out3 <= 32'hc063d405;
      138: out3 <= 32'hc07b371e;
      139: out3 <= 32'hc0950d1d;
      140: out3 <= 32'hc0b15502;
      141: out3 <= 32'hc0d00db6;
      142: out3 <= 32'hc0f1360b;
      143: out3 <= 32'hc114ccb9;
      144: out3 <= 32'hc13ad060;
      145: out3 <= 32'hc1633f8a;
      146: out3 <= 32'hc18e18a7;
      147: out3 <= 32'hc1bb5a11;
      148: out3 <= 32'hc1eb0209;
      149: out3 <= 32'hc21d0eb8;
      150: out3 <= 32'hc2517e31;
      151: out3 <= 32'hc2884e6e;
      152: out3 <= 32'hc2c17d52;
      153: out3 <= 32'hc2fd08a9;
      154: out3 <= 32'hc33aee27;
      155: out3 <= 32'hc37b2b6a;
      156: out3 <= 32'hc3bdbdf6;
      157: out3 <= 32'hc402a33c;
      158: out3 <= 32'hc449d892;
      159: out3 <= 32'hc4935b3c;
      160: out3 <= 32'hc4df2862;
      161: out3 <= 32'hc52d3d18;
      162: out3 <= 32'hc57d965d;
      163: out3 <= 32'hc5d03118;
      164: out3 <= 32'hc6250a18;
      165: out3 <= 32'hc67c1e18;
      166: out3 <= 32'hc6d569be;
      167: out3 <= 32'hc730e997;
      168: out3 <= 32'hc78e9a1d;
      169: out3 <= 32'hc7ee77b3;
      170: out3 <= 32'hc8507ea7;
      171: out3 <= 32'hc8b4ab32;
      172: out3 <= 32'hc91af976;
      173: out3 <= 32'hc9836582;
      174: out3 <= 32'hc9edeb50;
      175: out3 <= 32'hca5a86c4;
      176: out3 <= 32'hcac933ae;
      177: out3 <= 32'hcb39edca;
      178: out3 <= 32'hcbacb0bf;
      179: out3 <= 32'hcc217822;
      180: out3 <= 32'hcc983f70;
      181: out3 <= 32'hcd110216;
      182: out3 <= 32'hcd8bbb6d;
      183: out3 <= 32'hce0866b8;
      184: out3 <= 32'hce86ff2a;
      185: out3 <= 32'hcf077fe1;
      186: out3 <= 32'hcf89e3e8;
      187: out3 <= 32'hd00e2639;
      188: out3 <= 32'hd09441bb;
      189: out3 <= 32'hd11c3142;
      190: out3 <= 32'hd1a5ef90;
      191: out3 <= 32'hd2317756;
      192: out3 <= 32'hd2bec333;
      193: out3 <= 32'hd34dcdb4;
      194: out3 <= 32'hd3de9156;
      195: out3 <= 32'hd4710883;
      196: out3 <= 32'hd5052d97;
      197: out3 <= 32'hd59afadb;
      198: out3 <= 32'hd6326a88;
      199: out3 <= 32'hd6cb76c9;
      200: out3 <= 32'hd76619b6;
      201: out3 <= 32'hd8024d59;
      202: out3 <= 32'hd8a00bae;
      203: out3 <= 32'hd93f4e9e;
      204: out3 <= 32'hd9e01006;
      205: out3 <= 32'hda8249b4;
      206: out3 <= 32'hdb25f566;
      207: out3 <= 32'hdbcb0cce;
      208: out3 <= 32'hdc71898d;
      209: out3 <= 32'hdd196538;
      210: out3 <= 32'hddc29958;
      211: out3 <= 32'hde6d1f65;
      212: out3 <= 32'hdf18f0ce;
      213: out3 <= 32'hdfc606f1;
      214: out3 <= 32'he0745b24;
      215: out3 <= 32'he123e6ad;
      216: out3 <= 32'he1d4a2c8;
      217: out3 <= 32'he28688a4;
      218: out3 <= 32'he3399167;
      219: out3 <= 32'he3edb628;
      220: out3 <= 32'he4a2eff6;
      221: out3 <= 32'he55937d5;
      222: out3 <= 32'he61086bc;
      223: out3 <= 32'he6c8d59c;
      224: out3 <= 32'he7821d59;
      225: out3 <= 32'he83c56cf;
      226: out3 <= 32'he8f77acf;
      227: out3 <= 32'he9b38223;
      228: out3 <= 32'hea70658a;
      229: out3 <= 32'heb2e1dbe;
      230: out3 <= 32'hebeca36c;
      231: out3 <= 32'hecabef3d;
      232: out3 <= 32'hed6bf9d1;
      233: out3 <= 32'hee2cbbc1;
      234: out3 <= 32'heeee2d9d;
      235: out3 <= 32'hefb047f2;
      236: out3 <= 32'hf0730342;
      237: out3 <= 32'hf136580d;
      238: out3 <= 32'hf1fa3ecb;
      239: out3 <= 32'hf2beafed;
      240: out3 <= 32'hf383a3e2;
      241: out3 <= 32'hf4491311;
      242: out3 <= 32'hf50ef5de;
      243: out3 <= 32'hf5d544a7;
      244: out3 <= 32'hf69bf7c9;
      245: out3 <= 32'hf7630799;
      246: out3 <= 32'hf82a6c6a;
      247: out3 <= 32'hf8f21e8e;
      248: out3 <= 32'hf9ba1651;
      249: out3 <= 32'hfa824bfd;
      250: out3 <= 32'hfb4ab7db;
      251: out3 <= 32'hfc135231;
      252: out3 <= 32'hfcdc1342;
      253: out3 <= 32'hfda4f351;
      254: out3 <= 32'hfe6deaa1;
      255: out3 <= 32'hff36f170;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "block"
endmodule



module D6_55779(addr, out, clk);
   input clk;
   output [31:0] out;
   reg [31:0] out, out2, out3;
   input [7:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 32'h40000000;
      1: out3 <= 32'h3ffec42d;
      2: out3 <= 32'h3ffb10c1;
      3: out3 <= 32'h3ff4e5e0;
      4: out3 <= 32'h3fec43c7;
      5: out3 <= 32'h3fe12acb;
      6: out3 <= 32'h3fd39b5a;
      7: out3 <= 32'h3fc395f9;
      8: out3 <= 32'h3fb11b48;
      9: out3 <= 32'h3f9c2bfb;
      10: out3 <= 32'h3f84c8e2;
      11: out3 <= 32'h3f6af2e3;
      12: out3 <= 32'h3f4eaafe;
      13: out3 <= 32'h3f2ff24a;
      14: out3 <= 32'h3f0ec9f5;
      15: out3 <= 32'h3eeb3347;
      16: out3 <= 32'h3ec52fa0;
      17: out3 <= 32'h3e9cc076;
      18: out3 <= 32'h3e71e759;
      19: out3 <= 32'h3e44a5ef;
      20: out3 <= 32'h3e14fdf7;
      21: out3 <= 32'h3de2f148;
      22: out3 <= 32'h3dae81cf;
      23: out3 <= 32'h3d77b192;
      24: out3 <= 32'h3d3e82ae;
      25: out3 <= 32'h3d02f757;
      26: out3 <= 32'h3cc511d9;
      27: out3 <= 32'h3c84d496;
      28: out3 <= 32'h3c42420a;
      29: out3 <= 32'h3bfd5cc4;
      30: out3 <= 32'h3bb6276e;
      31: out3 <= 32'h3b6ca4c4;
      32: out3 <= 32'h3b20d79e;
      33: out3 <= 32'h3ad2c2e8;
      34: out3 <= 32'h3a8269a3;
      35: out3 <= 32'h3a2fcee8;
      36: out3 <= 32'h39daf5e8;
      37: out3 <= 32'h3983e1e8;
      38: out3 <= 32'h392a9642;
      39: out3 <= 32'h38cf1669;
      40: out3 <= 32'h387165e3;
      41: out3 <= 32'h3811884d;
      42: out3 <= 32'h37af8159;
      43: out3 <= 32'h374b54ce;
      44: out3 <= 32'h36e5068a;
      45: out3 <= 32'h367c9a7e;
      46: out3 <= 32'h361214b0;
      47: out3 <= 32'h35a5793c;
      48: out3 <= 32'h3536cc52;
      49: out3 <= 32'h34c61236;
      50: out3 <= 32'h34534f41;
      51: out3 <= 32'h33de87de;
      52: out3 <= 32'h3367c090;
      53: out3 <= 32'h32eefdea;
      54: out3 <= 32'h32744493;
      55: out3 <= 32'h31f79948;
      56: out3 <= 32'h317900d6;
      57: out3 <= 32'h30f8801f;
      58: out3 <= 32'h30761c18;
      59: out3 <= 32'h2ff1d9c7;
      60: out3 <= 32'h2f6bbe45;
      61: out3 <= 32'h2ee3cebe;
      62: out3 <= 32'h2e5a1070;
      63: out3 <= 32'h2dce88aa;
      64: out3 <= 32'h2d413ccd;
      65: out3 <= 32'h2cb2324c;
      66: out3 <= 32'h2c216eaa;
      67: out3 <= 32'h2b8ef77d;
      68: out3 <= 32'h2afad269;
      69: out3 <= 32'h2a650525;
      70: out3 <= 32'h29cd9578;
      71: out3 <= 32'h29348937;
      72: out3 <= 32'h2899e64a;
      73: out3 <= 32'h27fdb2a7;
      74: out3 <= 32'h275ff452;
      75: out3 <= 32'h26c0b162;
      76: out3 <= 32'h261feffa;
      77: out3 <= 32'h257db64c;
      78: out3 <= 32'h24da0a9a;
      79: out3 <= 32'h2434f332;
      80: out3 <= 32'h238e7673;
      81: out3 <= 32'h22e69ac8;
      82: out3 <= 32'h223d66a8;
      83: out3 <= 32'h2192e09b;
      84: out3 <= 32'h20e70f32;
      85: out3 <= 32'h2039f90f;
      86: out3 <= 32'h1f8ba4dc;
      87: out3 <= 32'h1edc1953;
      88: out3 <= 32'h1e2b5d38;
      89: out3 <= 32'h1d79775c;
      90: out3 <= 32'h1cc66e99;
      91: out3 <= 32'h1c1249d8;
      92: out3 <= 32'h1b5d100a;
      93: out3 <= 32'h1aa6c82b;
      94: out3 <= 32'h19ef7944;
      95: out3 <= 32'h19372a64;
      96: out3 <= 32'h187de2a7;
      97: out3 <= 32'h17c3a931;
      98: out3 <= 32'h17088531;
      99: out3 <= 32'h164c7ddd;
      100: out3 <= 32'h158f9a76;
      101: out3 <= 32'h14d1e242;
      102: out3 <= 32'h14135c94;
      103: out3 <= 32'h135410c3;
      104: out3 <= 32'h1294062f;
      105: out3 <= 32'h11d3443f;
      106: out3 <= 32'h1111d263;
      107: out3 <= 32'h104fb80e;
      108: out3 <= 32'hf8cfcbe;
      109: out3 <= 32'hec9a7f3;
      110: out3 <= 32'he05c135;
      111: out3 <= 32'hd415013;
      112: out3 <= 32'hc7c5c1e;
      113: out3 <= 32'hbb6ecef;
      114: out3 <= 32'haf10a22;
      115: out3 <= 32'ha2abb59;
      116: out3 <= 32'h9640837;
      117: out3 <= 32'h89cf867;
      118: out3 <= 32'h7d59396;
      119: out3 <= 32'h70de172;
      120: out3 <= 32'h645e9af;
      121: out3 <= 32'h57db403;
      122: out3 <= 32'h4b54825;
      123: out3 <= 32'h3ecadcf;
      124: out3 <= 32'h323ecbe;
      125: out3 <= 32'h25b0caf;
      126: out3 <= 32'h192155f;
      127: out3 <= 32'hc90e90;
      128: out3 <= 32'h0;
      129: out3 <= 32'hff36f170;
      130: out3 <= 32'hfe6deaa1;
      131: out3 <= 32'hfda4f351;
      132: out3 <= 32'hfcdc1342;
      133: out3 <= 32'hfc135231;
      134: out3 <= 32'hfb4ab7db;
      135: out3 <= 32'hfa824bfd;
      136: out3 <= 32'hf9ba1651;
      137: out3 <= 32'hf8f21e8e;
      138: out3 <= 32'hf82a6c6a;
      139: out3 <= 32'hf7630799;
      140: out3 <= 32'hf69bf7c9;
      141: out3 <= 32'hf5d544a7;
      142: out3 <= 32'hf50ef5de;
      143: out3 <= 32'hf4491311;
      144: out3 <= 32'hf383a3e2;
      145: out3 <= 32'hf2beafed;
      146: out3 <= 32'hf1fa3ecb;
      147: out3 <= 32'hf136580d;
      148: out3 <= 32'hf0730342;
      149: out3 <= 32'hefb047f2;
      150: out3 <= 32'heeee2d9d;
      151: out3 <= 32'hee2cbbc1;
      152: out3 <= 32'hed6bf9d1;
      153: out3 <= 32'hecabef3d;
      154: out3 <= 32'hebeca36c;
      155: out3 <= 32'heb2e1dbe;
      156: out3 <= 32'hea70658a;
      157: out3 <= 32'he9b38223;
      158: out3 <= 32'he8f77acf;
      159: out3 <= 32'he83c56cf;
      160: out3 <= 32'he7821d59;
      161: out3 <= 32'he6c8d59c;
      162: out3 <= 32'he61086bc;
      163: out3 <= 32'he55937d5;
      164: out3 <= 32'he4a2eff6;
      165: out3 <= 32'he3edb628;
      166: out3 <= 32'he3399167;
      167: out3 <= 32'he28688a4;
      168: out3 <= 32'he1d4a2c8;
      169: out3 <= 32'he123e6ad;
      170: out3 <= 32'he0745b24;
      171: out3 <= 32'hdfc606f1;
      172: out3 <= 32'hdf18f0ce;
      173: out3 <= 32'hde6d1f65;
      174: out3 <= 32'hddc29958;
      175: out3 <= 32'hdd196538;
      176: out3 <= 32'hdc71898d;
      177: out3 <= 32'hdbcb0cce;
      178: out3 <= 32'hdb25f566;
      179: out3 <= 32'hda8249b4;
      180: out3 <= 32'hd9e01006;
      181: out3 <= 32'hd93f4e9e;
      182: out3 <= 32'hd8a00bae;
      183: out3 <= 32'hd8024d59;
      184: out3 <= 32'hd76619b6;
      185: out3 <= 32'hd6cb76c9;
      186: out3 <= 32'hd6326a88;
      187: out3 <= 32'hd59afadb;
      188: out3 <= 32'hd5052d97;
      189: out3 <= 32'hd4710883;
      190: out3 <= 32'hd3de9156;
      191: out3 <= 32'hd34dcdb4;
      192: out3 <= 32'hd2bec333;
      193: out3 <= 32'hd2317756;
      194: out3 <= 32'hd1a5ef90;
      195: out3 <= 32'hd11c3142;
      196: out3 <= 32'hd09441bb;
      197: out3 <= 32'hd00e2639;
      198: out3 <= 32'hcf89e3e8;
      199: out3 <= 32'hcf077fe1;
      200: out3 <= 32'hce86ff2a;
      201: out3 <= 32'hce0866b8;
      202: out3 <= 32'hcd8bbb6d;
      203: out3 <= 32'hcd110216;
      204: out3 <= 32'hcc983f70;
      205: out3 <= 32'hcc217822;
      206: out3 <= 32'hcbacb0bf;
      207: out3 <= 32'hcb39edca;
      208: out3 <= 32'hcac933ae;
      209: out3 <= 32'hca5a86c4;
      210: out3 <= 32'hc9edeb50;
      211: out3 <= 32'hc9836582;
      212: out3 <= 32'hc91af976;
      213: out3 <= 32'hc8b4ab32;
      214: out3 <= 32'hc8507ea7;
      215: out3 <= 32'hc7ee77b3;
      216: out3 <= 32'hc78e9a1d;
      217: out3 <= 32'hc730e997;
      218: out3 <= 32'hc6d569be;
      219: out3 <= 32'hc67c1e18;
      220: out3 <= 32'hc6250a18;
      221: out3 <= 32'hc5d03118;
      222: out3 <= 32'hc57d965d;
      223: out3 <= 32'hc52d3d18;
      224: out3 <= 32'hc4df2862;
      225: out3 <= 32'hc4935b3c;
      226: out3 <= 32'hc449d892;
      227: out3 <= 32'hc402a33c;
      228: out3 <= 32'hc3bdbdf6;
      229: out3 <= 32'hc37b2b6a;
      230: out3 <= 32'hc33aee27;
      231: out3 <= 32'hc2fd08a9;
      232: out3 <= 32'hc2c17d52;
      233: out3 <= 32'hc2884e6e;
      234: out3 <= 32'hc2517e31;
      235: out3 <= 32'hc21d0eb8;
      236: out3 <= 32'hc1eb0209;
      237: out3 <= 32'hc1bb5a11;
      238: out3 <= 32'hc18e18a7;
      239: out3 <= 32'hc1633f8a;
      240: out3 <= 32'hc13ad060;
      241: out3 <= 32'hc114ccb9;
      242: out3 <= 32'hc0f1360b;
      243: out3 <= 32'hc0d00db6;
      244: out3 <= 32'hc0b15502;
      245: out3 <= 32'hc0950d1d;
      246: out3 <= 32'hc07b371e;
      247: out3 <= 32'hc063d405;
      248: out3 <= 32'hc04ee4b8;
      249: out3 <= 32'hc03c6a07;
      250: out3 <= 32'hc02c64a6;
      251: out3 <= 32'hc01ed535;
      252: out3 <= 32'hc013bc39;
      253: out3 <= 32'hc00b1a20;
      254: out3 <= 32'hc004ef3f;
      255: out3 <= 32'hc0013bd3;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "block"
endmodule



// Latency: 12
// Gap: 1
module codeBlock54587(clk, reset, next_in, next_out,
   i2_in,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3);

   output next_out;
   input clk, reset, next_in;

   reg next;
   input [7:0] i2_in;
   reg [7:0] i2;

   input [31:0] X0_in,
      X1_in,
      X2_in,
      X3_in;

   reg   [31:0] X0,
      X1,
      X2,
      X3;

   output [31:0] Y0,
      Y1,
      Y2,
      Y3;

   shiftRegFIFO #(11, 1) shiftFIFO_60147(.X(next), .Y(next_out), .clk(clk));


   wire signed [31:0] a113;
   wire signed [31:0] a102;
   wire signed [31:0] a116;
   wire signed [31:0] a106;
   wire signed [31:0] a117;
   wire signed [31:0] a118;
   reg signed [31:0] tm500;
   reg signed [31:0] tm504;
   reg signed [31:0] tm516;
   reg signed [31:0] tm527;
   reg signed [31:0] tm501;
   reg signed [31:0] tm505;
   reg signed [31:0] tm517;
   reg signed [31:0] tm528;
   wire signed [31:0] tm30;
   wire signed [31:0] a107;
   wire signed [31:0] tm31;
   wire signed [31:0] a109;
   reg signed [31:0] tm502;
   reg signed [31:0] tm506;
   reg signed [31:0] tm518;
   reg signed [31:0] tm529;
   reg signed [31:0] tm96;
   reg signed [31:0] tm97;
   reg signed [31:0] tm503;
   reg signed [31:0] tm507;
   reg signed [31:0] tm519;
   reg signed [31:0] tm530;
   reg signed [31:0] tm520;
   reg signed [31:0] tm531;
   reg signed [31:0] tm521;
   reg signed [31:0] tm532;
   reg signed [31:0] tm522;
   reg signed [31:0] tm533;
   reg signed [31:0] tm523;
   reg signed [31:0] tm534;
   reg signed [31:0] tm524;
   reg signed [31:0] tm535;
   wire signed [31:0] a108;
   wire signed [31:0] a110;
   wire signed [31:0] a111;
   wire signed [31:0] a112;
   reg signed [31:0] tm525;
   reg signed [31:0] tm536;
   wire signed [31:0] Y0;
   wire signed [31:0] Y1;
   wire signed [31:0] Y2;
   wire signed [31:0] Y3;
   reg signed [31:0] tm526;
   reg signed [31:0] tm537;


   assign a113 = X0;
   assign a102 = a113;
   assign a116 = X1;
   assign a106 = a116;
   assign a117 = X2;
   assign a118 = X3;
   assign a107 = tm30;
   assign a109 = tm31;
   assign Y0 = tm526;
   assign Y1 = tm537;

   D8_55005 instD8inst0_55005(.addr(i2[7:0]), .out(tm31), .clk(clk));

   D6_55779 instD6inst0_55779(.addr(i2[7:0]), .out(tm30), .clk(clk));

    multfix #(32, 6) m54686(.a(tm96), .b(tm503), .clk(clk), .q_sc(a108), .q_unsc(), .rst(reset));
    multfix #(32, 6) m54708(.a(tm97), .b(tm507), .clk(clk), .q_sc(a110), .q_unsc(), .rst(reset));
    multfix #(32, 6) m54726(.a(tm97), .b(tm503), .clk(clk), .q_sc(a111), .q_unsc(), .rst(reset));
    multfix #(32, 6) m54737(.a(tm96), .b(tm507), .clk(clk), .q_sc(a112), .q_unsc(), .rst(reset));
    subfxp #(32, 1) sub54715(.a(a108), .b(a110), .clk(clk), .q(Y2));    // 10
    addfxp #(32, 1) add54744(.a(a111), .b(a112), .clk(clk), .q(Y3));    // 10


   always @(posedge clk) begin
      if (reset == 1) begin
         tm96 <= 0;
         tm503 <= 0;
         tm97 <= 0;
         tm507 <= 0;
         tm97 <= 0;
         tm503 <= 0;
         tm96 <= 0;
         tm507 <= 0;
      end
      else begin
         i2 <= i2_in;
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         next <= next_in;
         tm500 <= a117;
         tm504 <= a118;
         tm516 <= a102;
         tm527 <= a106;
         tm501 <= tm500;
         tm505 <= tm504;
         tm517 <= tm516;
         tm528 <= tm527;
         tm502 <= tm501;
         tm506 <= tm505;
         tm518 <= tm517;
         tm529 <= tm528;
         tm96 <= a107;
         tm97 <= a109;
         tm503 <= tm502;
         tm507 <= tm506;
         tm519 <= tm518;
         tm530 <= tm529;
         tm520 <= tm519;
         tm531 <= tm530;
         tm521 <= tm520;
         tm532 <= tm531;
         tm522 <= tm521;
         tm533 <= tm532;
         tm523 <= tm522;
         tm534 <= tm533;
         tm524 <= tm523;
         tm535 <= tm534;
         tm525 <= tm524;
         tm536 <= tm535;
         tm526 <= tm525;
         tm537 <= tm536;
      end
   end
endmodule

// Latency: 2
// Gap: 1
module codeBlock55784(clk, reset, next_in, next_out,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3);

   output next_out;
   input clk, reset, next_in;

   reg next;

   input [31:0] X0_in,
      X1_in,
      X2_in,
      X3_in;

   reg   [31:0] X0,
      X1,
      X2,
      X3;

   output [31:0] Y0,
      Y1,
      Y2,
      Y3;

   shiftRegFIFO #(1, 1) shiftFIFO_60150(.X(next), .Y(next_out), .clk(clk));


   wire signed [31:0] a69;
   wire signed [31:0] a70;
   wire signed [31:0] a71;
   wire signed [31:0] a72;
   wire signed [31:0] t45;
   wire signed [31:0] t46;
   wire signed [31:0] t47;
   wire signed [31:0] t48;
   wire signed [31:0] Y0;
   wire signed [31:0] Y1;
   wire signed [31:0] Y2;
   wire signed [31:0] Y3;


   assign a69 = X0;
   assign a70 = X2;
   assign a71 = X1;
   assign a72 = X3;
   assign Y0 = t45;
   assign Y1 = t46;
   assign Y2 = t47;
   assign Y3 = t48;

    addfxp #(32, 1) add55796(.a(a69), .b(a70), .clk(clk), .q(t45));    // 0
    addfxp #(32, 1) add55811(.a(a71), .b(a72), .clk(clk), .q(t46));    // 0
    subfxp #(32, 1) sub55826(.a(a69), .b(a70), .clk(clk), .q(t47));    // 0
    subfxp #(32, 1) sub55841(.a(a71), .b(a72), .clk(clk), .q(t48));    // 0


   always @(posedge clk) begin
      if (reset == 1) begin
      end
      else begin
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         next <= next_in;
      end
   end
endmodule

// Latency: 259
// Gap: 512
module rc55865(clk, reset, next, next_out,
   X0, Y0,
   X1, Y1,
   X2, Y2,
   X3, Y3);

   output next_out;
   input clk, reset, next;

   input [31:0] X0,
      X1,
      X2,
      X3;

   output [31:0] Y0,
      Y1,
      Y2,
      Y3;

   wire [63:0] t0;
   wire [63:0] s0;
   assign t0 = {X0, X1};
   wire [63:0] t1;
   wire [63:0] s1;
   assign t1 = {X2, X3};
   assign Y0 = s0[63:32];
   assign Y1 = s0[31:0];
   assign Y2 = s1[63:32];
   assign Y3 = s1[31:0];

   perm55863 instPerm60151(.x0(t0), .y0(s0),
    .x1(t1), .y1(s1),
   .clk(clk), .next(next), .next_out(next_out), .reset(reset)
);



endmodule

// Latency: 259
// Gap: 512
module perm55863(clk, next, reset, next_out,
   x0, y0,
   x1, y1);
   parameter numBanks = 2;
   parameter logBanks = 1;
   parameter depth = 512;
   parameter logDepth = 9;
   parameter width = 64;

   input [width-1:0]  x0;
   output [width-1:0]  y0;
   wire [width-1:0]  ybuff0;
   input [width-1:0]  x1;
   output [width-1:0]  y1;
   wire [width-1:0]  ybuff1;
   input 	      clk, next, reset;
   output 	     next_out;

   wire    	     next0;

   reg              inFlip0, outFlip0;
   reg              inActive, outActive;

   wire [logBanks-1:0] inBank0, outBank0;
   wire [logDepth-1:0] inAddr0, outAddr0;
   wire [logBanks-1:0] outBank_a0;
   wire [logDepth-1:0] outAddr_a0;
   wire [logDepth+logBanks-1:0] addr0, addr0b, addr0c;
   wire [logBanks-1:0] inBank1, outBank1;
   wire [logDepth-1:0] inAddr1, outAddr1;
   wire [logBanks-1:0] outBank_a1;
   wire [logDepth-1:0] outAddr_a1;
   wire [logDepth+logBanks-1:0] addr1, addr1b, addr1c;


   reg [logDepth-1:0]  inCount, outCount, outCount_d, outCount_dd, outCount_for_rd_addr, outCount_for_rd_data;  

   assign    addr0 = {inCount, 1'd0};
   assign    addr0b = {outCount, 1'd0};
   assign    addr0c = {outCount_for_rd_addr, 1'd0};
   assign    addr1 = {inCount, 1'd1};
   assign    addr1b = {outCount, 1'd1};
   assign    addr1c = {outCount_for_rd_addr, 1'd1};
    wire [width+logDepth-1:0] w_0_0, w_0_1, w_1_0, w_1_1;

    reg [width-1:0] z_0_0;
    reg [width-1:0] z_0_1;
    wire [width-1:0] z_1_0, z_1_1;

    wire [logDepth-1:0] u_0_0, u_0_1, u_1_0, u_1_1;

    always @(posedge clk) begin
    end

   assign inBank0[0] = addr0[9] ^ addr0[0];
   assign inAddr0[0] = addr0[1];
   assign inAddr0[1] = addr0[2];
   assign inAddr0[2] = addr0[3];
   assign inAddr0[3] = addr0[4];
   assign inAddr0[4] = addr0[5];
   assign inAddr0[5] = addr0[6];
   assign inAddr0[6] = addr0[7];
   assign inAddr0[7] = addr0[8];
   assign inAddr0[8] = addr0[0];
   assign outBank0[0] = addr0b[9] ^ addr0b[0];
   assign outAddr0[0] = addr0b[1];
   assign outAddr0[1] = addr0b[2];
   assign outAddr0[2] = addr0b[3];
   assign outAddr0[3] = addr0b[4];
   assign outAddr0[4] = addr0b[5];
   assign outAddr0[5] = addr0b[6];
   assign outAddr0[6] = addr0b[7];
   assign outAddr0[7] = addr0b[8];
   assign outAddr0[8] = addr0b[9];
   assign outBank_a0[0] = addr0c[9] ^ addr0c[0];
   assign outAddr_a0[0] = addr0c[1];
   assign outAddr_a0[1] = addr0c[2];
   assign outAddr_a0[2] = addr0c[3];
   assign outAddr_a0[3] = addr0c[4];
   assign outAddr_a0[4] = addr0c[5];
   assign outAddr_a0[5] = addr0c[6];
   assign outAddr_a0[6] = addr0c[7];
   assign outAddr_a0[7] = addr0c[8];
   assign outAddr_a0[8] = addr0c[9];

   assign inBank1[0] = addr1[9] ^ addr1[0];
   assign inAddr1[0] = addr1[1];
   assign inAddr1[1] = addr1[2];
   assign inAddr1[2] = addr1[3];
   assign inAddr1[3] = addr1[4];
   assign inAddr1[4] = addr1[5];
   assign inAddr1[5] = addr1[6];
   assign inAddr1[6] = addr1[7];
   assign inAddr1[7] = addr1[8];
   assign inAddr1[8] = addr1[0];
   assign outBank1[0] = addr1b[9] ^ addr1b[0];
   assign outAddr1[0] = addr1b[1];
   assign outAddr1[1] = addr1b[2];
   assign outAddr1[2] = addr1b[3];
   assign outAddr1[3] = addr1b[4];
   assign outAddr1[4] = addr1b[5];
   assign outAddr1[5] = addr1b[6];
   assign outAddr1[6] = addr1b[7];
   assign outAddr1[7] = addr1b[8];
   assign outAddr1[8] = addr1b[9];
   assign outBank_a1[0] = addr1c[9] ^ addr1c[0];
   assign outAddr_a1[0] = addr1c[1];
   assign outAddr_a1[1] = addr1c[2];
   assign outAddr_a1[2] = addr1c[3];
   assign outAddr_a1[3] = addr1c[4];
   assign outAddr_a1[4] = addr1c[5];
   assign outAddr_a1[5] = addr1c[6];
   assign outAddr_a1[6] = addr1c[7];
   assign outAddr_a1[7] = addr1c[8];
   assign outAddr_a1[8] = addr1c[9];

   nextReg #(257, 9) nextReg_60156(.X(next), .Y(next0), .reset(reset), .clk(clk));


   shiftRegFIFO #(2, 1) shiftFIFO_60159(.X(next0), .Y(next_out), .clk(clk));


   memArray1024_55863 #(numBanks, logBanks, depth, logDepth, width)
     memSys(.inFlip(inFlip0), .outFlip(outFlip0), .next(next), .reset(reset),
        .x0(w_1_0[width+logDepth-1:logDepth]), .y0(ybuff0),
        .inAddr0(w_1_0[logDepth-1:0]),
        .outAddr0(u_1_0), 
        .x1(w_1_1[width+logDepth-1:logDepth]), .y1(ybuff1),
        .inAddr1(w_1_1[logDepth-1:0]),
        .outAddr1(u_1_1), 
        .clk(clk));

   always @(posedge clk) begin
      if (reset == 1) begin
      z_0_0 <= 0;
      z_0_1 <= 0;
         inFlip0 <= 0; outFlip0 <= 1; outCount <= 0; inCount <= 0;
        outCount_for_rd_addr <= 0;
        outCount_for_rd_data <= 0;
      end
      else begin
          outCount_d <= outCount;
          outCount_dd <= outCount_d;
         if (inCount == 256)
            outCount_for_rd_addr <= 0;
         else
            outCount_for_rd_addr <= outCount_for_rd_addr+1;
         if (inCount == 258)
            outCount_for_rd_data <= 0;
         else
            outCount_for_rd_data <= outCount_for_rd_data+1;
      z_0_0 <= ybuff0;
      z_0_1 <= ybuff1;
         if (inCount == 256) begin
            outFlip0 <= ~outFlip0;
            outCount <= 0;
         end
         else
            outCount <= outCount+1;
         if (inCount == 511) begin
            inFlip0 <= ~inFlip0;
         end
         if (next == 1) begin
            if (inCount >= 256)
               inFlip0 <= ~inFlip0;
            inCount <= 0;
         end
         else
            inCount <= inCount + 1;
      end
   end
    assign w_0_0 = {x0, inAddr0};
    assign w_0_1 = {x1, inAddr1};
    assign y0 = z_1_0;
    assign y1 = z_1_1;
    assign u_0_0 = outAddr_a0;
    assign u_0_1 = outAddr_a1;
    wire wr_ctrl_st_0;
    assign wr_ctrl_st_0 = inCount[8];

    switch #(logDepth+width) in_sw_0_0(.x0(w_0_0), .x1(w_0_1), .y0(w_1_0), .y1(w_1_1), .ctrl(wr_ctrl_st_0));
    wire rdd_ctrl_st_0;
    assign rdd_ctrl_st_0 = outCount_for_rd_data[8];

    switch #(width) out_sw_0_0(.x0(z_0_0), .x1(z_0_1), .y0(z_1_0), .y1(z_1_1), .ctrl(rdd_ctrl_st_0));
    wire rda_ctrl_st_0;
    assign rda_ctrl_st_0 = outCount_for_rd_addr[8];

    switch #(logDepth) rdaddr_sw_0_0(.x0(u_0_0), .x1(u_0_1), .y0(u_1_0), .y1(u_1_1), .ctrl(rda_ctrl_st_0));
endmodule

module memArray1024_55863(next, reset,
                x0, y0,
                inAddr0,
                outAddr0,
                x1, y1,
                inAddr1,
                outAddr1,
                clk, inFlip, outFlip);

   parameter numBanks = 2;
   parameter logBanks = 1;
   parameter depth = 512;
   parameter logDepth = 9;
   parameter width = 64;
         
   input     clk, next, reset;
   input    inFlip, outFlip;
   wire    next0;
   
   input [width-1:0]   x0;
   output [width-1:0]  y0;
   input [logDepth-1:0] inAddr0, outAddr0;
   input [width-1:0]   x1;
   output [width-1:0]  y1;
   input [logDepth-1:0] inAddr1, outAddr1;
   nextReg #(512, 9) nextReg_60164(.X(next), .Y(next0), .reset(reset), .clk(clk));


   memMod #(depth*2, width, logDepth+1) 
     memMod0(.in(x0), .out(y0), .inAddr({inFlip, inAddr0}),
	   .outAddr({outFlip, outAddr0}), .writeSel(1'b1), .clk(clk));   
   memMod #(depth*2, width, logDepth+1) 
     memMod1(.in(x1), .out(y1), .inAddr({inFlip, inAddr1}),
	   .outAddr({outFlip, outAddr1}), .writeSel(1'b1), .clk(clk));   
endmodule

// Latency: 12
// Gap: 512
module DirSum_58085(clk, reset, next, next_out,
      X0, Y0,
      X1, Y1,
      X2, Y2,
      X3, Y3);

   output next_out;
   input clk, reset, next;

   reg [8:0] i1;

   input [31:0] X0,
      X1,
      X2,
      X3;

   output [31:0] Y0,
      Y1,
      Y2,
      Y3;

   always @(posedge clk) begin
      if (reset == 1) begin
         i1 <= 0;
      end
      else begin
         if (next == 1)
            i1 <= 0;
         else if (i1 == 511)
            i1 <= 0;
         else
            i1 <= i1 + 1;
      end
   end

   codeBlock55867 codeBlockIsnt60169(.clk(clk), .reset(reset), .next_in(next), .next_out(next_out),
.i1_in(i1),
       .X0_in(X0), .Y0(Y0),
       .X1_in(X1), .Y1(Y1),
       .X2_in(X2), .Y2(Y2),
       .X3_in(X3), .Y3(Y3));

endmodule

module D4_57055(addr, out, clk);
   input clk;
   output [31:0] out;
   reg [31:0] out, out2, out3;
   input [8:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 32'h0;
      1: out3 <= 32'hff9b783c;
      2: out3 <= 32'hff36f170;
      3: out3 <= 32'hfed26c94;
      4: out3 <= 32'hfe6deaa1;
      5: out3 <= 32'hfe096c8d;
      6: out3 <= 32'hfda4f351;
      7: out3 <= 32'hfd407fe6;
      8: out3 <= 32'hfcdc1342;
      9: out3 <= 32'hfc77ae5e;
      10: out3 <= 32'hfc135231;
      11: out3 <= 32'hfbaeffb3;
      12: out3 <= 32'hfb4ab7db;
      13: out3 <= 32'hfae67ba2;
      14: out3 <= 32'hfa824bfd;
      15: out3 <= 32'hfa1e29e5;
      16: out3 <= 32'hf9ba1651;
      17: out3 <= 32'hf9561237;
      18: out3 <= 32'hf8f21e8e;
      19: out3 <= 32'hf88e3c4d;
      20: out3 <= 32'hf82a6c6a;
      21: out3 <= 32'hf7c6afdc;
      22: out3 <= 32'hf7630799;
      23: out3 <= 32'hf6ff7496;
      24: out3 <= 32'hf69bf7c9;
      25: out3 <= 32'hf6389228;
      26: out3 <= 32'hf5d544a7;
      27: out3 <= 32'hf572103d;
      28: out3 <= 32'hf50ef5de;
      29: out3 <= 32'hf4abf67e;
      30: out3 <= 32'hf4491311;
      31: out3 <= 32'hf3e64c8c;
      32: out3 <= 32'hf383a3e2;
      33: out3 <= 32'hf3211a07;
      34: out3 <= 32'hf2beafed;
      35: out3 <= 32'hf25c6688;
      36: out3 <= 32'hf1fa3ecb;
      37: out3 <= 32'hf19839a6;
      38: out3 <= 32'hf136580d;
      39: out3 <= 32'hf0d49af1;
      40: out3 <= 32'hf0730342;
      41: out3 <= 32'hf01191f3;
      42: out3 <= 32'hefb047f2;
      43: out3 <= 32'hef4f2630;
      44: out3 <= 32'heeee2d9d;
      45: out3 <= 32'hee8d5f29;
      46: out3 <= 32'hee2cbbc1;
      47: out3 <= 32'hedcc4454;
      48: out3 <= 32'hed6bf9d1;
      49: out3 <= 32'hed0bdd25;
      50: out3 <= 32'hecabef3d;
      51: out3 <= 32'hec4c3106;
      52: out3 <= 32'hebeca36c;
      53: out3 <= 32'heb8d475b;
      54: out3 <= 32'heb2e1dbe;
      55: out3 <= 32'heacf277f;
      56: out3 <= 32'hea70658a;
      57: out3 <= 32'hea11d8c8;
      58: out3 <= 32'he9b38223;
      59: out3 <= 32'he9556282;
      60: out3 <= 32'he8f77acf;
      61: out3 <= 32'he899cbf1;
      62: out3 <= 32'he83c56cf;
      63: out3 <= 32'he7df1c50;
      64: out3 <= 32'he7821d59;
      65: out3 <= 32'he7255ad1;
      66: out3 <= 32'he6c8d59c;
      67: out3 <= 32'he66c8e9f;
      68: out3 <= 32'he61086bc;
      69: out3 <= 32'he5b4bed8;
      70: out3 <= 32'he55937d5;
      71: out3 <= 32'he4fdf294;
      72: out3 <= 32'he4a2eff6;
      73: out3 <= 32'he44830dd;
      74: out3 <= 32'he3edb628;
      75: out3 <= 32'he39380b6;
      76: out3 <= 32'he3399167;
      77: out3 <= 32'he2dfe917;
      78: out3 <= 32'he28688a4;
      79: out3 <= 32'he22d70eb;
      80: out3 <= 32'he1d4a2c8;
      81: out3 <= 32'he17c1f15;
      82: out3 <= 32'he123e6ad;
      83: out3 <= 32'he0cbfa6a;
      84: out3 <= 32'he0745b24;
      85: out3 <= 32'he01d09b4;
      86: out3 <= 32'hdfc606f1;
      87: out3 <= 32'hdf6f53b3;
      88: out3 <= 32'hdf18f0ce;
      89: out3 <= 32'hdec2df18;
      90: out3 <= 32'hde6d1f65;
      91: out3 <= 32'hde17b28a;
      92: out3 <= 32'hddc29958;
      93: out3 <= 32'hdd6dd4a2;
      94: out3 <= 32'hdd196538;
      95: out3 <= 32'hdcc54bec;
      96: out3 <= 32'hdc71898d;
      97: out3 <= 32'hdc1e1ee9;
      98: out3 <= 32'hdbcb0cce;
      99: out3 <= 32'hdb785409;
      100: out3 <= 32'hdb25f566;
      101: out3 <= 32'hdad3f1b1;
      102: out3 <= 32'hda8249b4;
      103: out3 <= 32'hda30fe38;
      104: out3 <= 32'hd9e01006;
      105: out3 <= 32'hd98f7fe6;
      106: out3 <= 32'hd93f4e9e;
      107: out3 <= 32'hd8ef7cf4;
      108: out3 <= 32'hd8a00bae;
      109: out3 <= 32'hd850fb8e;
      110: out3 <= 32'hd8024d59;
      111: out3 <= 32'hd7b401d1;
      112: out3 <= 32'hd76619b6;
      113: out3 <= 32'hd71895c9;
      114: out3 <= 32'hd6cb76c9;
      115: out3 <= 32'hd67ebd74;
      116: out3 <= 32'hd6326a88;
      117: out3 <= 32'hd5e67ec1;
      118: out3 <= 32'hd59afadb;
      119: out3 <= 32'hd54fdf8f;
      120: out3 <= 32'hd5052d97;
      121: out3 <= 32'hd4bae5ab;
      122: out3 <= 32'hd4710883;
      123: out3 <= 32'hd42796d5;
      124: out3 <= 32'hd3de9156;
      125: out3 <= 32'hd395f8ba;
      126: out3 <= 32'hd34dcdb4;
      127: out3 <= 32'hd30610f7;
      128: out3 <= 32'hd2bec333;
      129: out3 <= 32'hd277e518;
      130: out3 <= 32'hd2317756;
      131: out3 <= 32'hd1eb7a9a;
      132: out3 <= 32'hd1a5ef90;
      133: out3 <= 32'hd160d6e5;
      134: out3 <= 32'hd11c3142;
      135: out3 <= 32'hd0d7ff51;
      136: out3 <= 32'hd09441bb;
      137: out3 <= 32'hd050f926;
      138: out3 <= 32'hd00e2639;
      139: out3 <= 32'hcfcbc999;
      140: out3 <= 32'hcf89e3e8;
      141: out3 <= 32'hcf4875ca;
      142: out3 <= 32'hcf077fe1;
      143: out3 <= 32'hcec702cb;
      144: out3 <= 32'hce86ff2a;
      145: out3 <= 32'hce47759a;
      146: out3 <= 32'hce0866b8;
      147: out3 <= 32'hcdc9d320;
      148: out3 <= 32'hcd8bbb6d;
      149: out3 <= 32'hcd4e2037;
      150: out3 <= 32'hcd110216;
      151: out3 <= 32'hccd461a2;
      152: out3 <= 32'hcc983f70;
      153: out3 <= 32'hcc5c9c14;
      154: out3 <= 32'hcc217822;
      155: out3 <= 32'hcbe6d42b;
      156: out3 <= 32'hcbacb0bf;
      157: out3 <= 32'hcb730e70;
      158: out3 <= 32'hcb39edca;
      159: out3 <= 32'hcb014f5b;
      160: out3 <= 32'hcac933ae;
      161: out3 <= 32'hca919b4e;
      162: out3 <= 32'hca5a86c4;
      163: out3 <= 32'hca23f698;
      164: out3 <= 32'hc9edeb50;
      165: out3 <= 32'hc9b86572;
      166: out3 <= 32'hc9836582;
      167: out3 <= 32'hc94eec03;
      168: out3 <= 32'hc91af976;
      169: out3 <= 32'hc8e78e5b;
      170: out3 <= 32'hc8b4ab32;
      171: out3 <= 32'hc8825077;
      172: out3 <= 32'hc8507ea7;
      173: out3 <= 32'hc81f363d;
      174: out3 <= 32'hc7ee77b3;
      175: out3 <= 32'hc7be4381;
      176: out3 <= 32'hc78e9a1d;
      177: out3 <= 32'hc75f7bfe;
      178: out3 <= 32'hc730e997;
      179: out3 <= 32'hc702e35c;
      180: out3 <= 32'hc6d569be;
      181: out3 <= 32'hc6a87d2d;
      182: out3 <= 32'hc67c1e18;
      183: out3 <= 32'hc6504ced;
      184: out3 <= 32'hc6250a18;
      185: out3 <= 32'hc5fa5603;
      186: out3 <= 32'hc5d03118;
      187: out3 <= 32'hc5a69bbe;
      188: out3 <= 32'hc57d965d;
      189: out3 <= 32'hc555215a;
      190: out3 <= 32'hc52d3d18;
      191: out3 <= 32'hc505e9fb;
      192: out3 <= 32'hc4df2862;
      193: out3 <= 32'hc4b8f8ad;
      194: out3 <= 32'hc4935b3c;
      195: out3 <= 32'hc46e5069;
      196: out3 <= 32'hc449d892;
      197: out3 <= 32'hc425f410;
      198: out3 <= 32'hc402a33c;
      199: out3 <= 32'hc3dfe66c;
      200: out3 <= 32'hc3bdbdf6;
      201: out3 <= 32'hc39c2a2f;
      202: out3 <= 32'hc37b2b6a;
      203: out3 <= 32'hc35ac1f7;
      204: out3 <= 32'hc33aee27;
      205: out3 <= 32'hc31bb049;
      206: out3 <= 32'hc2fd08a9;
      207: out3 <= 32'hc2def794;
      208: out3 <= 32'hc2c17d52;
      209: out3 <= 32'hc2a49a2e;
      210: out3 <= 32'hc2884e6e;
      211: out3 <= 32'hc26c9a58;
      212: out3 <= 32'hc2517e31;
      213: out3 <= 32'hc236fa3b;
      214: out3 <= 32'hc21d0eb8;
      215: out3 <= 32'hc203bbe8;
      216: out3 <= 32'hc1eb0209;
      217: out3 <= 32'hc1d2e158;
      218: out3 <= 32'hc1bb5a11;
      219: out3 <= 32'hc1a46c6e;
      220: out3 <= 32'hc18e18a7;
      221: out3 <= 32'hc1785ef4;
      222: out3 <= 32'hc1633f8a;
      223: out3 <= 32'hc14eba9d;
      224: out3 <= 32'hc13ad060;
      225: out3 <= 32'hc1278104;
      226: out3 <= 32'hc114ccb9;
      227: out3 <= 32'hc102b3ac;
      228: out3 <= 32'hc0f1360b;
      229: out3 <= 32'hc0e05401;
      230: out3 <= 32'hc0d00db6;
      231: out3 <= 32'hc0c06355;
      232: out3 <= 32'hc0b15502;
      233: out3 <= 32'hc0a2e2e3;
      234: out3 <= 32'hc0950d1d;
      235: out3 <= 32'hc087d3d0;
      236: out3 <= 32'hc07b371e;
      237: out3 <= 32'hc06f3726;
      238: out3 <= 32'hc063d405;
      239: out3 <= 32'hc0590dd8;
      240: out3 <= 32'hc04ee4b8;
      241: out3 <= 32'hc04558c0;
      242: out3 <= 32'hc03c6a07;
      243: out3 <= 32'hc03418a2;
      244: out3 <= 32'hc02c64a6;
      245: out3 <= 32'hc0254e27;
      246: out3 <= 32'hc01ed535;
      247: out3 <= 32'hc018f9e1;
      248: out3 <= 32'hc013bc39;
      249: out3 <= 32'hc00f1c4a;
      250: out3 <= 32'hc00b1a20;
      251: out3 <= 32'hc007b5c4;
      252: out3 <= 32'hc004ef3f;
      253: out3 <= 32'hc002c697;
      254: out3 <= 32'hc0013bd3;
      255: out3 <= 32'hc0004ef5;
      256: out3 <= 32'hc0000000;
      257: out3 <= 32'hc0004ef5;
      258: out3 <= 32'hc0013bd3;
      259: out3 <= 32'hc002c697;
      260: out3 <= 32'hc004ef3f;
      261: out3 <= 32'hc007b5c4;
      262: out3 <= 32'hc00b1a20;
      263: out3 <= 32'hc00f1c4a;
      264: out3 <= 32'hc013bc39;
      265: out3 <= 32'hc018f9e1;
      266: out3 <= 32'hc01ed535;
      267: out3 <= 32'hc0254e27;
      268: out3 <= 32'hc02c64a6;
      269: out3 <= 32'hc03418a2;
      270: out3 <= 32'hc03c6a07;
      271: out3 <= 32'hc04558c0;
      272: out3 <= 32'hc04ee4b8;
      273: out3 <= 32'hc0590dd8;
      274: out3 <= 32'hc063d405;
      275: out3 <= 32'hc06f3726;
      276: out3 <= 32'hc07b371e;
      277: out3 <= 32'hc087d3d0;
      278: out3 <= 32'hc0950d1d;
      279: out3 <= 32'hc0a2e2e3;
      280: out3 <= 32'hc0b15502;
      281: out3 <= 32'hc0c06355;
      282: out3 <= 32'hc0d00db6;
      283: out3 <= 32'hc0e05401;
      284: out3 <= 32'hc0f1360b;
      285: out3 <= 32'hc102b3ac;
      286: out3 <= 32'hc114ccb9;
      287: out3 <= 32'hc1278104;
      288: out3 <= 32'hc13ad060;
      289: out3 <= 32'hc14eba9d;
      290: out3 <= 32'hc1633f8a;
      291: out3 <= 32'hc1785ef4;
      292: out3 <= 32'hc18e18a7;
      293: out3 <= 32'hc1a46c6e;
      294: out3 <= 32'hc1bb5a11;
      295: out3 <= 32'hc1d2e158;
      296: out3 <= 32'hc1eb0209;
      297: out3 <= 32'hc203bbe8;
      298: out3 <= 32'hc21d0eb8;
      299: out3 <= 32'hc236fa3b;
      300: out3 <= 32'hc2517e31;
      301: out3 <= 32'hc26c9a58;
      302: out3 <= 32'hc2884e6e;
      303: out3 <= 32'hc2a49a2e;
      304: out3 <= 32'hc2c17d52;
      305: out3 <= 32'hc2def794;
      306: out3 <= 32'hc2fd08a9;
      307: out3 <= 32'hc31bb049;
      308: out3 <= 32'hc33aee27;
      309: out3 <= 32'hc35ac1f7;
      310: out3 <= 32'hc37b2b6a;
      311: out3 <= 32'hc39c2a2f;
      312: out3 <= 32'hc3bdbdf6;
      313: out3 <= 32'hc3dfe66c;
      314: out3 <= 32'hc402a33c;
      315: out3 <= 32'hc425f410;
      316: out3 <= 32'hc449d892;
      317: out3 <= 32'hc46e5069;
      318: out3 <= 32'hc4935b3c;
      319: out3 <= 32'hc4b8f8ad;
      320: out3 <= 32'hc4df2862;
      321: out3 <= 32'hc505e9fb;
      322: out3 <= 32'hc52d3d18;
      323: out3 <= 32'hc555215a;
      324: out3 <= 32'hc57d965d;
      325: out3 <= 32'hc5a69bbe;
      326: out3 <= 32'hc5d03118;
      327: out3 <= 32'hc5fa5603;
      328: out3 <= 32'hc6250a18;
      329: out3 <= 32'hc6504ced;
      330: out3 <= 32'hc67c1e18;
      331: out3 <= 32'hc6a87d2d;
      332: out3 <= 32'hc6d569be;
      333: out3 <= 32'hc702e35c;
      334: out3 <= 32'hc730e997;
      335: out3 <= 32'hc75f7bfe;
      336: out3 <= 32'hc78e9a1d;
      337: out3 <= 32'hc7be4381;
      338: out3 <= 32'hc7ee77b3;
      339: out3 <= 32'hc81f363d;
      340: out3 <= 32'hc8507ea7;
      341: out3 <= 32'hc8825077;
      342: out3 <= 32'hc8b4ab32;
      343: out3 <= 32'hc8e78e5b;
      344: out3 <= 32'hc91af976;
      345: out3 <= 32'hc94eec03;
      346: out3 <= 32'hc9836582;
      347: out3 <= 32'hc9b86572;
      348: out3 <= 32'hc9edeb50;
      349: out3 <= 32'hca23f698;
      350: out3 <= 32'hca5a86c4;
      351: out3 <= 32'hca919b4e;
      352: out3 <= 32'hcac933ae;
      353: out3 <= 32'hcb014f5b;
      354: out3 <= 32'hcb39edca;
      355: out3 <= 32'hcb730e70;
      356: out3 <= 32'hcbacb0bf;
      357: out3 <= 32'hcbe6d42b;
      358: out3 <= 32'hcc217822;
      359: out3 <= 32'hcc5c9c14;
      360: out3 <= 32'hcc983f70;
      361: out3 <= 32'hccd461a2;
      362: out3 <= 32'hcd110216;
      363: out3 <= 32'hcd4e2037;
      364: out3 <= 32'hcd8bbb6d;
      365: out3 <= 32'hcdc9d320;
      366: out3 <= 32'hce0866b8;
      367: out3 <= 32'hce47759a;
      368: out3 <= 32'hce86ff2a;
      369: out3 <= 32'hcec702cb;
      370: out3 <= 32'hcf077fe1;
      371: out3 <= 32'hcf4875ca;
      372: out3 <= 32'hcf89e3e8;
      373: out3 <= 32'hcfcbc999;
      374: out3 <= 32'hd00e2639;
      375: out3 <= 32'hd050f926;
      376: out3 <= 32'hd09441bb;
      377: out3 <= 32'hd0d7ff51;
      378: out3 <= 32'hd11c3142;
      379: out3 <= 32'hd160d6e5;
      380: out3 <= 32'hd1a5ef90;
      381: out3 <= 32'hd1eb7a9a;
      382: out3 <= 32'hd2317756;
      383: out3 <= 32'hd277e518;
      384: out3 <= 32'hd2bec333;
      385: out3 <= 32'hd30610f7;
      386: out3 <= 32'hd34dcdb4;
      387: out3 <= 32'hd395f8ba;
      388: out3 <= 32'hd3de9156;
      389: out3 <= 32'hd42796d5;
      390: out3 <= 32'hd4710883;
      391: out3 <= 32'hd4bae5ab;
      392: out3 <= 32'hd5052d97;
      393: out3 <= 32'hd54fdf8f;
      394: out3 <= 32'hd59afadb;
      395: out3 <= 32'hd5e67ec1;
      396: out3 <= 32'hd6326a88;
      397: out3 <= 32'hd67ebd74;
      398: out3 <= 32'hd6cb76c9;
      399: out3 <= 32'hd71895c9;
      400: out3 <= 32'hd76619b6;
      401: out3 <= 32'hd7b401d1;
      402: out3 <= 32'hd8024d59;
      403: out3 <= 32'hd850fb8e;
      404: out3 <= 32'hd8a00bae;
      405: out3 <= 32'hd8ef7cf4;
      406: out3 <= 32'hd93f4e9e;
      407: out3 <= 32'hd98f7fe6;
      408: out3 <= 32'hd9e01006;
      409: out3 <= 32'hda30fe38;
      410: out3 <= 32'hda8249b4;
      411: out3 <= 32'hdad3f1b1;
      412: out3 <= 32'hdb25f566;
      413: out3 <= 32'hdb785409;
      414: out3 <= 32'hdbcb0cce;
      415: out3 <= 32'hdc1e1ee9;
      416: out3 <= 32'hdc71898d;
      417: out3 <= 32'hdcc54bec;
      418: out3 <= 32'hdd196538;
      419: out3 <= 32'hdd6dd4a2;
      420: out3 <= 32'hddc29958;
      421: out3 <= 32'hde17b28a;
      422: out3 <= 32'hde6d1f65;
      423: out3 <= 32'hdec2df18;
      424: out3 <= 32'hdf18f0ce;
      425: out3 <= 32'hdf6f53b3;
      426: out3 <= 32'hdfc606f1;
      427: out3 <= 32'he01d09b4;
      428: out3 <= 32'he0745b24;
      429: out3 <= 32'he0cbfa6a;
      430: out3 <= 32'he123e6ad;
      431: out3 <= 32'he17c1f15;
      432: out3 <= 32'he1d4a2c8;
      433: out3 <= 32'he22d70eb;
      434: out3 <= 32'he28688a4;
      435: out3 <= 32'he2dfe917;
      436: out3 <= 32'he3399167;
      437: out3 <= 32'he39380b6;
      438: out3 <= 32'he3edb628;
      439: out3 <= 32'he44830dd;
      440: out3 <= 32'he4a2eff6;
      441: out3 <= 32'he4fdf294;
      442: out3 <= 32'he55937d5;
      443: out3 <= 32'he5b4bed8;
      444: out3 <= 32'he61086bc;
      445: out3 <= 32'he66c8e9f;
      446: out3 <= 32'he6c8d59c;
      447: out3 <= 32'he7255ad1;
      448: out3 <= 32'he7821d59;
      449: out3 <= 32'he7df1c50;
      450: out3 <= 32'he83c56cf;
      451: out3 <= 32'he899cbf1;
      452: out3 <= 32'he8f77acf;
      453: out3 <= 32'he9556282;
      454: out3 <= 32'he9b38223;
      455: out3 <= 32'hea11d8c8;
      456: out3 <= 32'hea70658a;
      457: out3 <= 32'heacf277f;
      458: out3 <= 32'heb2e1dbe;
      459: out3 <= 32'heb8d475b;
      460: out3 <= 32'hebeca36c;
      461: out3 <= 32'hec4c3106;
      462: out3 <= 32'hecabef3d;
      463: out3 <= 32'hed0bdd25;
      464: out3 <= 32'hed6bf9d1;
      465: out3 <= 32'hedcc4454;
      466: out3 <= 32'hee2cbbc1;
      467: out3 <= 32'hee8d5f29;
      468: out3 <= 32'heeee2d9d;
      469: out3 <= 32'hef4f2630;
      470: out3 <= 32'hefb047f2;
      471: out3 <= 32'hf01191f3;
      472: out3 <= 32'hf0730342;
      473: out3 <= 32'hf0d49af1;
      474: out3 <= 32'hf136580d;
      475: out3 <= 32'hf19839a6;
      476: out3 <= 32'hf1fa3ecb;
      477: out3 <= 32'hf25c6688;
      478: out3 <= 32'hf2beafed;
      479: out3 <= 32'hf3211a07;
      480: out3 <= 32'hf383a3e2;
      481: out3 <= 32'hf3e64c8c;
      482: out3 <= 32'hf4491311;
      483: out3 <= 32'hf4abf67e;
      484: out3 <= 32'hf50ef5de;
      485: out3 <= 32'hf572103d;
      486: out3 <= 32'hf5d544a7;
      487: out3 <= 32'hf6389228;
      488: out3 <= 32'hf69bf7c9;
      489: out3 <= 32'hf6ff7496;
      490: out3 <= 32'hf7630799;
      491: out3 <= 32'hf7c6afdc;
      492: out3 <= 32'hf82a6c6a;
      493: out3 <= 32'hf88e3c4d;
      494: out3 <= 32'hf8f21e8e;
      495: out3 <= 32'hf9561237;
      496: out3 <= 32'hf9ba1651;
      497: out3 <= 32'hfa1e29e5;
      498: out3 <= 32'hfa824bfd;
      499: out3 <= 32'hfae67ba2;
      500: out3 <= 32'hfb4ab7db;
      501: out3 <= 32'hfbaeffb3;
      502: out3 <= 32'hfc135231;
      503: out3 <= 32'hfc77ae5e;
      504: out3 <= 32'hfcdc1342;
      505: out3 <= 32'hfd407fe6;
      506: out3 <= 32'hfda4f351;
      507: out3 <= 32'hfe096c8d;
      508: out3 <= 32'hfe6deaa1;
      509: out3 <= 32'hfed26c94;
      510: out3 <= 32'hff36f170;
      511: out3 <= 32'hff9b783c;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "block"
endmodule



module D2_58083(addr, out, clk);
   input clk;
   output [31:0] out;
   reg [31:0] out, out2, out3;
   input [8:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 32'h40000000;
      1: out3 <= 32'h3fffb10b;
      2: out3 <= 32'h3ffec42d;
      3: out3 <= 32'h3ffd3969;
      4: out3 <= 32'h3ffb10c1;
      5: out3 <= 32'h3ff84a3c;
      6: out3 <= 32'h3ff4e5e0;
      7: out3 <= 32'h3ff0e3b6;
      8: out3 <= 32'h3fec43c7;
      9: out3 <= 32'h3fe7061f;
      10: out3 <= 32'h3fe12acb;
      11: out3 <= 32'h3fdab1d9;
      12: out3 <= 32'h3fd39b5a;
      13: out3 <= 32'h3fcbe75e;
      14: out3 <= 32'h3fc395f9;
      15: out3 <= 32'h3fbaa740;
      16: out3 <= 32'h3fb11b48;
      17: out3 <= 32'h3fa6f228;
      18: out3 <= 32'h3f9c2bfb;
      19: out3 <= 32'h3f90c8da;
      20: out3 <= 32'h3f84c8e2;
      21: out3 <= 32'h3f782c30;
      22: out3 <= 32'h3f6af2e3;
      23: out3 <= 32'h3f5d1d1d;
      24: out3 <= 32'h3f4eaafe;
      25: out3 <= 32'h3f3f9cab;
      26: out3 <= 32'h3f2ff24a;
      27: out3 <= 32'h3f1fabff;
      28: out3 <= 32'h3f0ec9f5;
      29: out3 <= 32'h3efd4c54;
      30: out3 <= 32'h3eeb3347;
      31: out3 <= 32'h3ed87efc;
      32: out3 <= 32'h3ec52fa0;
      33: out3 <= 32'h3eb14563;
      34: out3 <= 32'h3e9cc076;
      35: out3 <= 32'h3e87a10c;
      36: out3 <= 32'h3e71e759;
      37: out3 <= 32'h3e5b9392;
      38: out3 <= 32'h3e44a5ef;
      39: out3 <= 32'h3e2d1ea8;
      40: out3 <= 32'h3e14fdf7;
      41: out3 <= 32'h3dfc4418;
      42: out3 <= 32'h3de2f148;
      43: out3 <= 32'h3dc905c5;
      44: out3 <= 32'h3dae81cf;
      45: out3 <= 32'h3d9365a8;
      46: out3 <= 32'h3d77b192;
      47: out3 <= 32'h3d5b65d2;
      48: out3 <= 32'h3d3e82ae;
      49: out3 <= 32'h3d21086c;
      50: out3 <= 32'h3d02f757;
      51: out3 <= 32'h3ce44fb7;
      52: out3 <= 32'h3cc511d9;
      53: out3 <= 32'h3ca53e09;
      54: out3 <= 32'h3c84d496;
      55: out3 <= 32'h3c63d5d1;
      56: out3 <= 32'h3c42420a;
      57: out3 <= 32'h3c201994;
      58: out3 <= 32'h3bfd5cc4;
      59: out3 <= 32'h3bda0bf0;
      60: out3 <= 32'h3bb6276e;
      61: out3 <= 32'h3b91af97;
      62: out3 <= 32'h3b6ca4c4;
      63: out3 <= 32'h3b470753;
      64: out3 <= 32'h3b20d79e;
      65: out3 <= 32'h3afa1605;
      66: out3 <= 32'h3ad2c2e8;
      67: out3 <= 32'h3aaadea6;
      68: out3 <= 32'h3a8269a3;
      69: out3 <= 32'h3a596442;
      70: out3 <= 32'h3a2fcee8;
      71: out3 <= 32'h3a05a9fd;
      72: out3 <= 32'h39daf5e8;
      73: out3 <= 32'h39afb313;
      74: out3 <= 32'h3983e1e8;
      75: out3 <= 32'h395782d3;
      76: out3 <= 32'h392a9642;
      77: out3 <= 32'h38fd1ca4;
      78: out3 <= 32'h38cf1669;
      79: out3 <= 32'h38a08402;
      80: out3 <= 32'h387165e3;
      81: out3 <= 32'h3841bc7f;
      82: out3 <= 32'h3811884d;
      83: out3 <= 32'h37e0c9c3;
      84: out3 <= 32'h37af8159;
      85: out3 <= 32'h377daf89;
      86: out3 <= 32'h374b54ce;
      87: out3 <= 32'h371871a5;
      88: out3 <= 32'h36e5068a;
      89: out3 <= 32'h36b113fd;
      90: out3 <= 32'h367c9a7e;
      91: out3 <= 32'h36479a8e;
      92: out3 <= 32'h361214b0;
      93: out3 <= 32'h35dc0968;
      94: out3 <= 32'h35a5793c;
      95: out3 <= 32'h356e64b2;
      96: out3 <= 32'h3536cc52;
      97: out3 <= 32'h34feb0a5;
      98: out3 <= 32'h34c61236;
      99: out3 <= 32'h348cf190;
      100: out3 <= 32'h34534f41;
      101: out3 <= 32'h34192bd5;
      102: out3 <= 32'h33de87de;
      103: out3 <= 32'h33a363ec;
      104: out3 <= 32'h3367c090;
      105: out3 <= 32'h332b9e5e;
      106: out3 <= 32'h32eefdea;
      107: out3 <= 32'h32b1dfc9;
      108: out3 <= 32'h32744493;
      109: out3 <= 32'h32362ce0;
      110: out3 <= 32'h31f79948;
      111: out3 <= 32'h31b88a66;
      112: out3 <= 32'h317900d6;
      113: out3 <= 32'h3138fd35;
      114: out3 <= 32'h30f8801f;
      115: out3 <= 32'h30b78a36;
      116: out3 <= 32'h30761c18;
      117: out3 <= 32'h30343667;
      118: out3 <= 32'h2ff1d9c7;
      119: out3 <= 32'h2faf06da;
      120: out3 <= 32'h2f6bbe45;
      121: out3 <= 32'h2f2800af;
      122: out3 <= 32'h2ee3cebe;
      123: out3 <= 32'h2e9f291b;
      124: out3 <= 32'h2e5a1070;
      125: out3 <= 32'h2e148566;
      126: out3 <= 32'h2dce88aa;
      127: out3 <= 32'h2d881ae8;
      128: out3 <= 32'h2d413ccd;
      129: out3 <= 32'h2cf9ef09;
      130: out3 <= 32'h2cb2324c;
      131: out3 <= 32'h2c6a0746;
      132: out3 <= 32'h2c216eaa;
      133: out3 <= 32'h2bd8692b;
      134: out3 <= 32'h2b8ef77d;
      135: out3 <= 32'h2b451a55;
      136: out3 <= 32'h2afad269;
      137: out3 <= 32'h2ab02071;
      138: out3 <= 32'h2a650525;
      139: out3 <= 32'h2a19813f;
      140: out3 <= 32'h29cd9578;
      141: out3 <= 32'h2981428c;
      142: out3 <= 32'h29348937;
      143: out3 <= 32'h28e76a37;
      144: out3 <= 32'h2899e64a;
      145: out3 <= 32'h284bfe2f;
      146: out3 <= 32'h27fdb2a7;
      147: out3 <= 32'h27af0472;
      148: out3 <= 32'h275ff452;
      149: out3 <= 32'h2710830c;
      150: out3 <= 32'h26c0b162;
      151: out3 <= 32'h2670801a;
      152: out3 <= 32'h261feffa;
      153: out3 <= 32'h25cf01c8;
      154: out3 <= 32'h257db64c;
      155: out3 <= 32'h252c0e4f;
      156: out3 <= 32'h24da0a9a;
      157: out3 <= 32'h2487abf7;
      158: out3 <= 32'h2434f332;
      159: out3 <= 32'h23e1e117;
      160: out3 <= 32'h238e7673;
      161: out3 <= 32'h233ab414;
      162: out3 <= 32'h22e69ac8;
      163: out3 <= 32'h22922b5e;
      164: out3 <= 32'h223d66a8;
      165: out3 <= 32'h21e84d76;
      166: out3 <= 32'h2192e09b;
      167: out3 <= 32'h213d20e8;
      168: out3 <= 32'h20e70f32;
      169: out3 <= 32'h2090ac4d;
      170: out3 <= 32'h2039f90f;
      171: out3 <= 32'h1fe2f64c;
      172: out3 <= 32'h1f8ba4dc;
      173: out3 <= 32'h1f340596;
      174: out3 <= 32'h1edc1953;
      175: out3 <= 32'h1e83e0eb;
      176: out3 <= 32'h1e2b5d38;
      177: out3 <= 32'h1dd28f15;
      178: out3 <= 32'h1d79775c;
      179: out3 <= 32'h1d2016e9;
      180: out3 <= 32'h1cc66e99;
      181: out3 <= 32'h1c6c7f4a;
      182: out3 <= 32'h1c1249d8;
      183: out3 <= 32'h1bb7cf23;
      184: out3 <= 32'h1b5d100a;
      185: out3 <= 32'h1b020d6c;
      186: out3 <= 32'h1aa6c82b;
      187: out3 <= 32'h1a4b4128;
      188: out3 <= 32'h19ef7944;
      189: out3 <= 32'h19937161;
      190: out3 <= 32'h19372a64;
      191: out3 <= 32'h18daa52f;
      192: out3 <= 32'h187de2a7;
      193: out3 <= 32'h1820e3b0;
      194: out3 <= 32'h17c3a931;
      195: out3 <= 32'h1766340f;
      196: out3 <= 32'h17088531;
      197: out3 <= 32'h16aa9d7e;
      198: out3 <= 32'h164c7ddd;
      199: out3 <= 32'h15ee2738;
      200: out3 <= 32'h158f9a76;
      201: out3 <= 32'h1530d881;
      202: out3 <= 32'h14d1e242;
      203: out3 <= 32'h1472b8a5;
      204: out3 <= 32'h14135c94;
      205: out3 <= 32'h13b3cefa;
      206: out3 <= 32'h135410c3;
      207: out3 <= 32'h12f422db;
      208: out3 <= 32'h1294062f;
      209: out3 <= 32'h1233bbac;
      210: out3 <= 32'h11d3443f;
      211: out3 <= 32'h1172a0d7;
      212: out3 <= 32'h1111d263;
      213: out3 <= 32'h10b0d9d0;
      214: out3 <= 32'h104fb80e;
      215: out3 <= 32'hfee6e0d;
      216: out3 <= 32'hf8cfcbe;
      217: out3 <= 32'hf2b650f;
      218: out3 <= 32'hec9a7f3;
      219: out3 <= 32'he67c65a;
      220: out3 <= 32'he05c135;
      221: out3 <= 32'hda39978;
      222: out3 <= 32'hd415013;
      223: out3 <= 32'hcdee5f9;
      224: out3 <= 32'hc7c5c1e;
      225: out3 <= 32'hc19b374;
      226: out3 <= 32'hbb6ecef;
      227: out3 <= 32'hb540982;
      228: out3 <= 32'haf10a22;
      229: out3 <= 32'ha8defc3;
      230: out3 <= 32'ha2abb59;
      231: out3 <= 32'h9c76dd8;
      232: out3 <= 32'h9640837;
      233: out3 <= 32'h9008b6a;
      234: out3 <= 32'h89cf867;
      235: out3 <= 32'h8395024;
      236: out3 <= 32'h7d59396;
      237: out3 <= 32'h771c3b3;
      238: out3 <= 32'h70de172;
      239: out3 <= 32'h6a9edc9;
      240: out3 <= 32'h645e9af;
      241: out3 <= 32'h5e1d61b;
      242: out3 <= 32'h57db403;
      243: out3 <= 32'h519845e;
      244: out3 <= 32'h4b54825;
      245: out3 <= 32'h451004d;
      246: out3 <= 32'h3ecadcf;
      247: out3 <= 32'h38851a2;
      248: out3 <= 32'h323ecbe;
      249: out3 <= 32'h2bf801a;
      250: out3 <= 32'h25b0caf;
      251: out3 <= 32'h1f69373;
      252: out3 <= 32'h192155f;
      253: out3 <= 32'h12d936c;
      254: out3 <= 32'hc90e90;
      255: out3 <= 32'h6487c4;
      256: out3 <= 32'h0;
      257: out3 <= 32'hff9b783c;
      258: out3 <= 32'hff36f170;
      259: out3 <= 32'hfed26c94;
      260: out3 <= 32'hfe6deaa1;
      261: out3 <= 32'hfe096c8d;
      262: out3 <= 32'hfda4f351;
      263: out3 <= 32'hfd407fe6;
      264: out3 <= 32'hfcdc1342;
      265: out3 <= 32'hfc77ae5e;
      266: out3 <= 32'hfc135231;
      267: out3 <= 32'hfbaeffb3;
      268: out3 <= 32'hfb4ab7db;
      269: out3 <= 32'hfae67ba2;
      270: out3 <= 32'hfa824bfd;
      271: out3 <= 32'hfa1e29e5;
      272: out3 <= 32'hf9ba1651;
      273: out3 <= 32'hf9561237;
      274: out3 <= 32'hf8f21e8e;
      275: out3 <= 32'hf88e3c4d;
      276: out3 <= 32'hf82a6c6a;
      277: out3 <= 32'hf7c6afdc;
      278: out3 <= 32'hf7630799;
      279: out3 <= 32'hf6ff7496;
      280: out3 <= 32'hf69bf7c9;
      281: out3 <= 32'hf6389228;
      282: out3 <= 32'hf5d544a7;
      283: out3 <= 32'hf572103d;
      284: out3 <= 32'hf50ef5de;
      285: out3 <= 32'hf4abf67e;
      286: out3 <= 32'hf4491311;
      287: out3 <= 32'hf3e64c8c;
      288: out3 <= 32'hf383a3e2;
      289: out3 <= 32'hf3211a07;
      290: out3 <= 32'hf2beafed;
      291: out3 <= 32'hf25c6688;
      292: out3 <= 32'hf1fa3ecb;
      293: out3 <= 32'hf19839a6;
      294: out3 <= 32'hf136580d;
      295: out3 <= 32'hf0d49af1;
      296: out3 <= 32'hf0730342;
      297: out3 <= 32'hf01191f3;
      298: out3 <= 32'hefb047f2;
      299: out3 <= 32'hef4f2630;
      300: out3 <= 32'heeee2d9d;
      301: out3 <= 32'hee8d5f29;
      302: out3 <= 32'hee2cbbc1;
      303: out3 <= 32'hedcc4454;
      304: out3 <= 32'hed6bf9d1;
      305: out3 <= 32'hed0bdd25;
      306: out3 <= 32'hecabef3d;
      307: out3 <= 32'hec4c3106;
      308: out3 <= 32'hebeca36c;
      309: out3 <= 32'heb8d475b;
      310: out3 <= 32'heb2e1dbe;
      311: out3 <= 32'heacf277f;
      312: out3 <= 32'hea70658a;
      313: out3 <= 32'hea11d8c8;
      314: out3 <= 32'he9b38223;
      315: out3 <= 32'he9556282;
      316: out3 <= 32'he8f77acf;
      317: out3 <= 32'he899cbf1;
      318: out3 <= 32'he83c56cf;
      319: out3 <= 32'he7df1c50;
      320: out3 <= 32'he7821d59;
      321: out3 <= 32'he7255ad1;
      322: out3 <= 32'he6c8d59c;
      323: out3 <= 32'he66c8e9f;
      324: out3 <= 32'he61086bc;
      325: out3 <= 32'he5b4bed8;
      326: out3 <= 32'he55937d5;
      327: out3 <= 32'he4fdf294;
      328: out3 <= 32'he4a2eff6;
      329: out3 <= 32'he44830dd;
      330: out3 <= 32'he3edb628;
      331: out3 <= 32'he39380b6;
      332: out3 <= 32'he3399167;
      333: out3 <= 32'he2dfe917;
      334: out3 <= 32'he28688a4;
      335: out3 <= 32'he22d70eb;
      336: out3 <= 32'he1d4a2c8;
      337: out3 <= 32'he17c1f15;
      338: out3 <= 32'he123e6ad;
      339: out3 <= 32'he0cbfa6a;
      340: out3 <= 32'he0745b24;
      341: out3 <= 32'he01d09b4;
      342: out3 <= 32'hdfc606f1;
      343: out3 <= 32'hdf6f53b3;
      344: out3 <= 32'hdf18f0ce;
      345: out3 <= 32'hdec2df18;
      346: out3 <= 32'hde6d1f65;
      347: out3 <= 32'hde17b28a;
      348: out3 <= 32'hddc29958;
      349: out3 <= 32'hdd6dd4a2;
      350: out3 <= 32'hdd196538;
      351: out3 <= 32'hdcc54bec;
      352: out3 <= 32'hdc71898d;
      353: out3 <= 32'hdc1e1ee9;
      354: out3 <= 32'hdbcb0cce;
      355: out3 <= 32'hdb785409;
      356: out3 <= 32'hdb25f566;
      357: out3 <= 32'hdad3f1b1;
      358: out3 <= 32'hda8249b4;
      359: out3 <= 32'hda30fe38;
      360: out3 <= 32'hd9e01006;
      361: out3 <= 32'hd98f7fe6;
      362: out3 <= 32'hd93f4e9e;
      363: out3 <= 32'hd8ef7cf4;
      364: out3 <= 32'hd8a00bae;
      365: out3 <= 32'hd850fb8e;
      366: out3 <= 32'hd8024d59;
      367: out3 <= 32'hd7b401d1;
      368: out3 <= 32'hd76619b6;
      369: out3 <= 32'hd71895c9;
      370: out3 <= 32'hd6cb76c9;
      371: out3 <= 32'hd67ebd74;
      372: out3 <= 32'hd6326a88;
      373: out3 <= 32'hd5e67ec1;
      374: out3 <= 32'hd59afadb;
      375: out3 <= 32'hd54fdf8f;
      376: out3 <= 32'hd5052d97;
      377: out3 <= 32'hd4bae5ab;
      378: out3 <= 32'hd4710883;
      379: out3 <= 32'hd42796d5;
      380: out3 <= 32'hd3de9156;
      381: out3 <= 32'hd395f8ba;
      382: out3 <= 32'hd34dcdb4;
      383: out3 <= 32'hd30610f7;
      384: out3 <= 32'hd2bec333;
      385: out3 <= 32'hd277e518;
      386: out3 <= 32'hd2317756;
      387: out3 <= 32'hd1eb7a9a;
      388: out3 <= 32'hd1a5ef90;
      389: out3 <= 32'hd160d6e5;
      390: out3 <= 32'hd11c3142;
      391: out3 <= 32'hd0d7ff51;
      392: out3 <= 32'hd09441bb;
      393: out3 <= 32'hd050f926;
      394: out3 <= 32'hd00e2639;
      395: out3 <= 32'hcfcbc999;
      396: out3 <= 32'hcf89e3e8;
      397: out3 <= 32'hcf4875ca;
      398: out3 <= 32'hcf077fe1;
      399: out3 <= 32'hcec702cb;
      400: out3 <= 32'hce86ff2a;
      401: out3 <= 32'hce47759a;
      402: out3 <= 32'hce0866b8;
      403: out3 <= 32'hcdc9d320;
      404: out3 <= 32'hcd8bbb6d;
      405: out3 <= 32'hcd4e2037;
      406: out3 <= 32'hcd110216;
      407: out3 <= 32'hccd461a2;
      408: out3 <= 32'hcc983f70;
      409: out3 <= 32'hcc5c9c14;
      410: out3 <= 32'hcc217822;
      411: out3 <= 32'hcbe6d42b;
      412: out3 <= 32'hcbacb0bf;
      413: out3 <= 32'hcb730e70;
      414: out3 <= 32'hcb39edca;
      415: out3 <= 32'hcb014f5b;
      416: out3 <= 32'hcac933ae;
      417: out3 <= 32'hca919b4e;
      418: out3 <= 32'hca5a86c4;
      419: out3 <= 32'hca23f698;
      420: out3 <= 32'hc9edeb50;
      421: out3 <= 32'hc9b86572;
      422: out3 <= 32'hc9836582;
      423: out3 <= 32'hc94eec03;
      424: out3 <= 32'hc91af976;
      425: out3 <= 32'hc8e78e5b;
      426: out3 <= 32'hc8b4ab32;
      427: out3 <= 32'hc8825077;
      428: out3 <= 32'hc8507ea7;
      429: out3 <= 32'hc81f363d;
      430: out3 <= 32'hc7ee77b3;
      431: out3 <= 32'hc7be4381;
      432: out3 <= 32'hc78e9a1d;
      433: out3 <= 32'hc75f7bfe;
      434: out3 <= 32'hc730e997;
      435: out3 <= 32'hc702e35c;
      436: out3 <= 32'hc6d569be;
      437: out3 <= 32'hc6a87d2d;
      438: out3 <= 32'hc67c1e18;
      439: out3 <= 32'hc6504ced;
      440: out3 <= 32'hc6250a18;
      441: out3 <= 32'hc5fa5603;
      442: out3 <= 32'hc5d03118;
      443: out3 <= 32'hc5a69bbe;
      444: out3 <= 32'hc57d965d;
      445: out3 <= 32'hc555215a;
      446: out3 <= 32'hc52d3d18;
      447: out3 <= 32'hc505e9fb;
      448: out3 <= 32'hc4df2862;
      449: out3 <= 32'hc4b8f8ad;
      450: out3 <= 32'hc4935b3c;
      451: out3 <= 32'hc46e5069;
      452: out3 <= 32'hc449d892;
      453: out3 <= 32'hc425f410;
      454: out3 <= 32'hc402a33c;
      455: out3 <= 32'hc3dfe66c;
      456: out3 <= 32'hc3bdbdf6;
      457: out3 <= 32'hc39c2a2f;
      458: out3 <= 32'hc37b2b6a;
      459: out3 <= 32'hc35ac1f7;
      460: out3 <= 32'hc33aee27;
      461: out3 <= 32'hc31bb049;
      462: out3 <= 32'hc2fd08a9;
      463: out3 <= 32'hc2def794;
      464: out3 <= 32'hc2c17d52;
      465: out3 <= 32'hc2a49a2e;
      466: out3 <= 32'hc2884e6e;
      467: out3 <= 32'hc26c9a58;
      468: out3 <= 32'hc2517e31;
      469: out3 <= 32'hc236fa3b;
      470: out3 <= 32'hc21d0eb8;
      471: out3 <= 32'hc203bbe8;
      472: out3 <= 32'hc1eb0209;
      473: out3 <= 32'hc1d2e158;
      474: out3 <= 32'hc1bb5a11;
      475: out3 <= 32'hc1a46c6e;
      476: out3 <= 32'hc18e18a7;
      477: out3 <= 32'hc1785ef4;
      478: out3 <= 32'hc1633f8a;
      479: out3 <= 32'hc14eba9d;
      480: out3 <= 32'hc13ad060;
      481: out3 <= 32'hc1278104;
      482: out3 <= 32'hc114ccb9;
      483: out3 <= 32'hc102b3ac;
      484: out3 <= 32'hc0f1360b;
      485: out3 <= 32'hc0e05401;
      486: out3 <= 32'hc0d00db6;
      487: out3 <= 32'hc0c06355;
      488: out3 <= 32'hc0b15502;
      489: out3 <= 32'hc0a2e2e3;
      490: out3 <= 32'hc0950d1d;
      491: out3 <= 32'hc087d3d0;
      492: out3 <= 32'hc07b371e;
      493: out3 <= 32'hc06f3726;
      494: out3 <= 32'hc063d405;
      495: out3 <= 32'hc0590dd8;
      496: out3 <= 32'hc04ee4b8;
      497: out3 <= 32'hc04558c0;
      498: out3 <= 32'hc03c6a07;
      499: out3 <= 32'hc03418a2;
      500: out3 <= 32'hc02c64a6;
      501: out3 <= 32'hc0254e27;
      502: out3 <= 32'hc01ed535;
      503: out3 <= 32'hc018f9e1;
      504: out3 <= 32'hc013bc39;
      505: out3 <= 32'hc00f1c4a;
      506: out3 <= 32'hc00b1a20;
      507: out3 <= 32'hc007b5c4;
      508: out3 <= 32'hc004ef3f;
      509: out3 <= 32'hc002c697;
      510: out3 <= 32'hc0013bd3;
      511: out3 <= 32'hc0004ef5;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "block"
endmodule



// Latency: 12
// Gap: 1
module codeBlock55867(clk, reset, next_in, next_out,
   i1_in,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3);

   output next_out;
   input clk, reset, next_in;

   reg next;
   input [8:0] i1_in;
   reg [8:0] i1;

   input [31:0] X0_in,
      X1_in,
      X2_in,
      X3_in;

   reg   [31:0] X0,
      X1,
      X2,
      X3;

   output [31:0] Y0,
      Y1,
      Y2,
      Y3;

   shiftRegFIFO #(11, 1) shiftFIFO_60172(.X(next), .Y(next_out), .clk(clk));


   wire signed [31:0] a53;
   wire signed [31:0] a42;
   wire signed [31:0] a56;
   wire signed [31:0] a46;
   wire signed [31:0] a57;
   wire signed [31:0] a58;
   reg signed [31:0] tm538;
   reg signed [31:0] tm542;
   reg signed [31:0] tm554;
   reg signed [31:0] tm565;
   reg signed [31:0] tm539;
   reg signed [31:0] tm543;
   reg signed [31:0] tm555;
   reg signed [31:0] tm566;
   wire signed [31:0] tm34;
   wire signed [31:0] a47;
   wire signed [31:0] tm35;
   wire signed [31:0] a49;
   reg signed [31:0] tm540;
   reg signed [31:0] tm544;
   reg signed [31:0] tm556;
   reg signed [31:0] tm567;
   reg signed [31:0] tm104;
   reg signed [31:0] tm105;
   reg signed [31:0] tm541;
   reg signed [31:0] tm545;
   reg signed [31:0] tm557;
   reg signed [31:0] tm568;
   reg signed [31:0] tm558;
   reg signed [31:0] tm569;
   reg signed [31:0] tm559;
   reg signed [31:0] tm570;
   reg signed [31:0] tm560;
   reg signed [31:0] tm571;
   reg signed [31:0] tm561;
   reg signed [31:0] tm572;
   reg signed [31:0] tm562;
   reg signed [31:0] tm573;
   wire signed [31:0] a48;
   wire signed [31:0] a50;
   wire signed [31:0] a51;
   wire signed [31:0] a52;
   reg signed [31:0] tm563;
   reg signed [31:0] tm574;
   wire signed [31:0] Y0;
   wire signed [31:0] Y1;
   wire signed [31:0] Y2;
   wire signed [31:0] Y3;
   reg signed [31:0] tm564;
   reg signed [31:0] tm575;


   assign a53 = X0;
   assign a42 = a53;
   assign a56 = X1;
   assign a46 = a56;
   assign a57 = X2;
   assign a58 = X3;
   assign a47 = tm34;
   assign a49 = tm35;
   assign Y0 = tm564;
   assign Y1 = tm575;

   D4_57055 instD4inst0_57055(.addr(i1[8:0]), .out(tm35), .clk(clk));

   D2_58083 instD2inst0_58083(.addr(i1[8:0]), .out(tm34), .clk(clk));

    multfix #(32, 6) m55966(.a(tm104), .b(tm541), .clk(clk), .q_sc(a48), .q_unsc(), .rst(reset));
    multfix #(32, 6) m55988(.a(tm105), .b(tm545), .clk(clk), .q_sc(a50), .q_unsc(), .rst(reset));
    multfix #(32, 6) m56006(.a(tm105), .b(tm541), .clk(clk), .q_sc(a51), .q_unsc(), .rst(reset));
    multfix #(32, 6) m56017(.a(tm104), .b(tm545), .clk(clk), .q_sc(a52), .q_unsc(), .rst(reset));
    subfxp #(32, 1) sub55995(.a(a48), .b(a50), .clk(clk), .q(Y2));    // 10
    addfxp #(32, 1) add56024(.a(a51), .b(a52), .clk(clk), .q(Y3));    // 10


   always @(posedge clk) begin
      if (reset == 1) begin
         tm104 <= 0;
         tm541 <= 0;
         tm105 <= 0;
         tm545 <= 0;
         tm105 <= 0;
         tm541 <= 0;
         tm104 <= 0;
         tm545 <= 0;
      end
      else begin
         i1 <= i1_in;
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         next <= next_in;
         tm538 <= a57;
         tm542 <= a58;
         tm554 <= a42;
         tm565 <= a46;
         tm539 <= tm538;
         tm543 <= tm542;
         tm555 <= tm554;
         tm566 <= tm565;
         tm540 <= tm539;
         tm544 <= tm543;
         tm556 <= tm555;
         tm567 <= tm566;
         tm104 <= a47;
         tm105 <= a49;
         tm541 <= tm540;
         tm545 <= tm544;
         tm557 <= tm556;
         tm568 <= tm567;
         tm558 <= tm557;
         tm569 <= tm568;
         tm559 <= tm558;
         tm570 <= tm569;
         tm560 <= tm559;
         tm571 <= tm570;
         tm561 <= tm560;
         tm572 <= tm571;
         tm562 <= tm561;
         tm573 <= tm572;
         tm563 <= tm562;
         tm574 <= tm573;
         tm564 <= tm563;
         tm575 <= tm574;
      end
   end
endmodule

// Latency: 2
// Gap: 1
module codeBlock58088(clk, reset, next_in, next_out,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3);

   output next_out;
   input clk, reset, next_in;

   reg next;

   input [31:0] X0_in,
      X1_in,
      X2_in,
      X3_in;

   reg   [31:0] X0,
      X1,
      X2,
      X3;

   output [31:0] Y0,
      Y1,
      Y2,
      Y3;

   shiftRegFIFO #(1, 1) shiftFIFO_60175(.X(next), .Y(next_out), .clk(clk));


   wire signed [31:0] a9;
   wire signed [31:0] a10;
   wire signed [31:0] a11;
   wire signed [31:0] a12;
   wire signed [31:0] t21;
   wire signed [31:0] t22;
   wire signed [31:0] t23;
   wire signed [31:0] t24;
   wire signed [31:0] Y0;
   wire signed [31:0] Y1;
   wire signed [31:0] Y2;
   wire signed [31:0] Y3;


   assign a9 = X0;
   assign a10 = X2;
   assign a11 = X1;
   assign a12 = X3;
   assign Y0 = t21;
   assign Y1 = t22;
   assign Y2 = t23;
   assign Y3 = t24;

    addfxp #(32, 1) add58100(.a(a9), .b(a10), .clk(clk), .q(t21));    // 0
    addfxp #(32, 1) add58115(.a(a11), .b(a12), .clk(clk), .q(t22));    // 0
    subfxp #(32, 1) sub58130(.a(a9), .b(a10), .clk(clk), .q(t23));    // 0
    subfxp #(32, 1) sub58145(.a(a11), .b(a12), .clk(clk), .q(t24));    // 0


   always @(posedge clk) begin
      if (reset == 1) begin
      end
      else begin
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         next <= next_in;
      end
   end
endmodule

// Latency: 259
// Gap: 512
module rc58169(clk, reset, next, next_out,
   X0, Y0,
   X1, Y1,
   X2, Y2,
   X3, Y3);

   output next_out;
   input clk, reset, next;

   input [31:0] X0,
      X1,
      X2,
      X3;

   output [31:0] Y0,
      Y1,
      Y2,
      Y3;

   wire [63:0] t0;
   wire [63:0] s0;
   assign t0 = {X0, X1};
   wire [63:0] t1;
   wire [63:0] s1;
   assign t1 = {X2, X3};
   assign Y0 = s0[63:32];
   assign Y1 = s0[31:0];
   assign Y2 = s1[63:32];
   assign Y3 = s1[31:0];

   perm58167 instPerm60176(.x0(t0), .y0(s0),
    .x1(t1), .y1(s1),
   .clk(clk), .next(next), .next_out(next_out), .reset(reset)
);



endmodule

// Latency: 259
// Gap: 512
module perm58167(clk, next, reset, next_out,
   x0, y0,
   x1, y1);
   parameter numBanks = 2;
   parameter logBanks = 1;
   parameter depth = 512;
   parameter logDepth = 9;
   parameter width = 64;

   input [width-1:0]  x0;
   output [width-1:0]  y0;
   wire [width-1:0]  ybuff0;
   input [width-1:0]  x1;
   output [width-1:0]  y1;
   wire [width-1:0]  ybuff1;
   input 	      clk, next, reset;
   output 	     next_out;

   wire    	     next0;

   reg              inFlip0, outFlip0;
   reg              inActive, outActive;

   wire [logBanks-1:0] inBank0, outBank0;
   wire [logDepth-1:0] inAddr0, outAddr0;
   wire [logBanks-1:0] outBank_a0;
   wire [logDepth-1:0] outAddr_a0;
   wire [logDepth+logBanks-1:0] addr0, addr0b, addr0c;
   wire [logBanks-1:0] inBank1, outBank1;
   wire [logDepth-1:0] inAddr1, outAddr1;
   wire [logBanks-1:0] outBank_a1;
   wire [logDepth-1:0] outAddr_a1;
   wire [logDepth+logBanks-1:0] addr1, addr1b, addr1c;


   reg [logDepth-1:0]  inCount, outCount, outCount_d, outCount_dd, outCount_for_rd_addr, outCount_for_rd_data;  

   assign    addr0 = {inCount, 1'd0};
   assign    addr0b = {outCount, 1'd0};
   assign    addr0c = {outCount_for_rd_addr, 1'd0};
   assign    addr1 = {inCount, 1'd1};
   assign    addr1b = {outCount, 1'd1};
   assign    addr1c = {outCount_for_rd_addr, 1'd1};
    wire [width+logDepth-1:0] w_0_0, w_0_1, w_1_0, w_1_1;

    reg [width-1:0] z_0_0;
    reg [width-1:0] z_0_1;
    wire [width-1:0] z_1_0, z_1_1;

    wire [logDepth-1:0] u_0_0, u_0_1, u_1_0, u_1_1;

    always @(posedge clk) begin
    end

   assign inBank0[0] = addr0[1] ^ addr0[0];
   assign inAddr0[0] = addr0[2];
   assign inAddr0[1] = addr0[3];
   assign inAddr0[2] = addr0[4];
   assign inAddr0[3] = addr0[5];
   assign inAddr0[4] = addr0[6];
   assign inAddr0[5] = addr0[7];
   assign inAddr0[6] = addr0[8];
   assign inAddr0[7] = addr0[9];
   assign inAddr0[8] = addr0[0];
   assign outBank0[0] = addr0b[9] ^ addr0b[0];
   assign outAddr0[0] = addr0b[1];
   assign outAddr0[1] = addr0b[2];
   assign outAddr0[2] = addr0b[3];
   assign outAddr0[3] = addr0b[4];
   assign outAddr0[4] = addr0b[5];
   assign outAddr0[5] = addr0b[6];
   assign outAddr0[6] = addr0b[7];
   assign outAddr0[7] = addr0b[8];
   assign outAddr0[8] = addr0b[9];
   assign outBank_a0[0] = addr0c[9] ^ addr0c[0];
   assign outAddr_a0[0] = addr0c[1];
   assign outAddr_a0[1] = addr0c[2];
   assign outAddr_a0[2] = addr0c[3];
   assign outAddr_a0[3] = addr0c[4];
   assign outAddr_a0[4] = addr0c[5];
   assign outAddr_a0[5] = addr0c[6];
   assign outAddr_a0[6] = addr0c[7];
   assign outAddr_a0[7] = addr0c[8];
   assign outAddr_a0[8] = addr0c[9];

   assign inBank1[0] = addr1[1] ^ addr1[0];
   assign inAddr1[0] = addr1[2];
   assign inAddr1[1] = addr1[3];
   assign inAddr1[2] = addr1[4];
   assign inAddr1[3] = addr1[5];
   assign inAddr1[4] = addr1[6];
   assign inAddr1[5] = addr1[7];
   assign inAddr1[6] = addr1[8];
   assign inAddr1[7] = addr1[9];
   assign inAddr1[8] = addr1[0];
   assign outBank1[0] = addr1b[9] ^ addr1b[0];
   assign outAddr1[0] = addr1b[1];
   assign outAddr1[1] = addr1b[2];
   assign outAddr1[2] = addr1b[3];
   assign outAddr1[3] = addr1b[4];
   assign outAddr1[4] = addr1b[5];
   assign outAddr1[5] = addr1b[6];
   assign outAddr1[6] = addr1b[7];
   assign outAddr1[7] = addr1b[8];
   assign outAddr1[8] = addr1b[9];
   assign outBank_a1[0] = addr1c[9] ^ addr1c[0];
   assign outAddr_a1[0] = addr1c[1];
   assign outAddr_a1[1] = addr1c[2];
   assign outAddr_a1[2] = addr1c[3];
   assign outAddr_a1[3] = addr1c[4];
   assign outAddr_a1[4] = addr1c[5];
   assign outAddr_a1[5] = addr1c[6];
   assign outAddr_a1[6] = addr1c[7];
   assign outAddr_a1[7] = addr1c[8];
   assign outAddr_a1[8] = addr1c[9];

   nextReg #(257, 9) nextReg_60181(.X(next), .Y(next0), .reset(reset), .clk(clk));


   shiftRegFIFO #(2, 1) shiftFIFO_60184(.X(next0), .Y(next_out), .clk(clk));


   memArray1024_58167 #(numBanks, logBanks, depth, logDepth, width)
     memSys(.inFlip(inFlip0), .outFlip(outFlip0), .next(next), .reset(reset),
        .x0(w_1_0[width+logDepth-1:logDepth]), .y0(ybuff0),
        .inAddr0(w_1_0[logDepth-1:0]),
        .outAddr0(u_1_0), 
        .x1(w_1_1[width+logDepth-1:logDepth]), .y1(ybuff1),
        .inAddr1(w_1_1[logDepth-1:0]),
        .outAddr1(u_1_1), 
        .clk(clk));

   always @(posedge clk) begin
      if (reset == 1) begin
      z_0_0 <= 0;
      z_0_1 <= 0;
         inFlip0 <= 0; outFlip0 <= 1; outCount <= 0; inCount <= 0;
        outCount_for_rd_addr <= 0;
        outCount_for_rd_data <= 0;
      end
      else begin
          outCount_d <= outCount;
          outCount_dd <= outCount_d;
         if (inCount == 256)
            outCount_for_rd_addr <= 0;
         else
            outCount_for_rd_addr <= outCount_for_rd_addr+1;
         if (inCount == 258)
            outCount_for_rd_data <= 0;
         else
            outCount_for_rd_data <= outCount_for_rd_data+1;
      z_0_0 <= ybuff0;
      z_0_1 <= ybuff1;
         if (inCount == 256) begin
            outFlip0 <= ~outFlip0;
            outCount <= 0;
         end
         else
            outCount <= outCount+1;
         if (inCount == 511) begin
            inFlip0 <= ~inFlip0;
         end
         if (next == 1) begin
            if (inCount >= 256)
               inFlip0 <= ~inFlip0;
            inCount <= 0;
         end
         else
            inCount <= inCount + 1;
      end
   end
    assign w_0_0 = {x0, inAddr0};
    assign w_0_1 = {x1, inAddr1};
    assign y0 = z_1_0;
    assign y1 = z_1_1;
    assign u_0_0 = outAddr_a0;
    assign u_0_1 = outAddr_a1;
    wire wr_ctrl_st_0;
    assign wr_ctrl_st_0 = inCount[0];

    switch #(logDepth+width) in_sw_0_0(.x0(w_0_0), .x1(w_0_1), .y0(w_1_0), .y1(w_1_1), .ctrl(wr_ctrl_st_0));
    wire rdd_ctrl_st_0;
    assign rdd_ctrl_st_0 = outCount_for_rd_data[8];

    switch #(width) out_sw_0_0(.x0(z_0_0), .x1(z_0_1), .y0(z_1_0), .y1(z_1_1), .ctrl(rdd_ctrl_st_0));
    wire rda_ctrl_st_0;
    assign rda_ctrl_st_0 = outCount_for_rd_addr[8];

    switch #(logDepth) rdaddr_sw_0_0(.x0(u_0_0), .x1(u_0_1), .y0(u_1_0), .y1(u_1_1), .ctrl(rda_ctrl_st_0));
endmodule

module memArray1024_58167(next, reset,
                x0, y0,
                inAddr0,
                outAddr0,
                x1, y1,
                inAddr1,
                outAddr1,
                clk, inFlip, outFlip);

   parameter numBanks = 2;
   parameter logBanks = 1;
   parameter depth = 512;
   parameter logDepth = 9;
   parameter width = 64;
         
   input     clk, next, reset;
   input    inFlip, outFlip;
   wire    next0;
   
   input [width-1:0]   x0;
   output [width-1:0]  y0;
   input [logDepth-1:0] inAddr0, outAddr0;
   input [width-1:0]   x1;
   output [width-1:0]  y1;
   input [logDepth-1:0] inAddr1, outAddr1;
   nextReg #(512, 9) nextReg_60189(.X(next), .Y(next0), .reset(reset), .clk(clk));


   memMod #(depth*2, width, logDepth+1) 
     memMod0(.in(x0), .out(y0), .inAddr({inFlip, inAddr0}),
	   .outAddr({outFlip, outAddr0}), .writeSel(1'b1), .clk(clk));   
   memMod #(depth*2, width, logDepth+1) 
     memMod1(.in(x1), .out(y1), .inAddr({inFlip, inAddr1}),
	   .outAddr({outFlip, outAddr1}), .writeSel(1'b1), .clk(clk));   
endmodule


						module multfix(clk, rst, a, b, q_sc, q_unsc);
						   parameter WIDTH=35, CYCLES=6;

						   input signed [WIDTH-1:0]    a,b;
						   output [WIDTH-1:0]          q_sc;
						   output [WIDTH-1:0]              q_unsc;

						   input                       clk, rst;
						   
						   reg signed [2*WIDTH-1:0]    q[CYCLES-1:0];
						   wire signed [2*WIDTH-1:0]   res;   
						   integer                     i;

						   assign                      res = q[CYCLES-1];   
						   
						   assign                      q_unsc = res[WIDTH-1:0];
						   assign                      q_sc = {res[2*WIDTH-1], res[2*WIDTH-4:WIDTH-2]};
						      
						   always @(posedge clk) begin
						      q[0] <= a * b;
						      for (i = 1; i < CYCLES; i=i+1) begin
						         q[i] <= q[i-1];
						      end
						   end
						                  
						endmodule 
module addfxp(a, b, q, clk);

   parameter width = 16, cycles=1;
   
   input signed [width-1:0]  a, b;
   input                     clk;   
   output signed [width-1:0] q;
   reg signed [width-1:0]    res[cycles-1:0];

   assign                    q = res[cycles-1];
   
   integer                   i;   
   
   always @(posedge clk) begin
     res[0] <= a+b;
      for (i=1; i < cycles; i = i+1)
        res[i] <= res[i-1];
      
   end
   
endmodule

module subfxp(a, b, q, clk);

   parameter width = 16, cycles=1;
   
   input signed [width-1:0]  a, b;
   input                     clk;   
   output signed [width-1:0] q;
   reg signed [width-1:0]    res[cycles-1:0];

   assign                    q = res[cycles-1];
   
   integer                   i;   
   
   always @(posedge clk) begin
     res[0] <= a-b;
      for (i=1; i < cycles; i = i+1)
        res[i] <= res[i-1];
      
   end
  
endmodule